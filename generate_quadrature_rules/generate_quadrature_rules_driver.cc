
# include <fstream>
# include <vector>
# include <functional>

# include "./quadrule.h"

/*
  Compile using:
  g++ generate_quadrature_rules_driver.cc quadrule.cc -Wall -g -Wconversion --std=c++0x

  Sorry this code is such a mess, it was written to work for all dimensions but
  the resulting file was far too large so it is rather overcomplicating things
  for just 1D calculations.

  Details of the function used (from quadrule.cpp):

  Purpose:

  LEGENDRE_DR_COMPUTE: Gauss-Legendre quadrature by Davis-Rabinowitz method.

  Discussion:

  The integral:

  Integral ( -1 <= X <= 1 ) F(X) dX

  The quadrature rule:

  Sum ( 1 <= I <= ORDER ) WEIGHT(I) * F ( XTAB(I) )

  ............

  Parameters:

  Input, int ORDER, the order.
  ORDER must be greater than 0.

  Output, double XTAB[ORDER], the abscissas.

  Output, double WEIGHT[ORDER], the weights.
*/

// void output_weight_knot(const std::vector<double> &weight, const unsigned &length,
// 			std::ofstream &rules_stream)
// {
//   rules_stream << "{";
//   for(unsigned i=0; i<length; i++)
//     rules_stream << weight[i] << ",";
//   rules_stream << "}," << std::endl;
// }

void quad_compute_weights(const std::function<void(unsigned,double*,double*)>
			  &one_d_weights_compute,
			  std::ofstream &rules_stream, const unsigned &max_order)
{

  //============================================================
  /// Pre-calculate weights in 1D
  //============================================================

  std::vector<std::vector<double> > weight_1d(max_order+1);
  for(unsigned order=1; order<=max_order; order++)
    {
      double temp_weight[order], temp_knot[order];
      one_d_weights_compute(order,temp_knot,temp_weight);

      weight_1d[order].resize(order);
      for(unsigned i=0; i<order; i++)
	weight_1d[order][i] = temp_weight[i];
    }


  //=================================================================
  // Output weights in 1D
  //=================================================================

  // Output the weights for dimension 1
  rules_stream << "{" << std::endl
	       << "{}," << std::endl;
  for(unsigned order=1; order<=max_order; order++)
    {
      // Dump weights
      rules_stream << "{";
      for(unsigned i=0; i<order; i++)
	rules_stream << weight_1d[order][i] << ",";
      rules_stream << "}," << std::endl;
    }
  rules_stream << "};" << std::endl
	       << std::endl;
}

void quad_compute_knots(const std::function<void(unsigned,double*,double*)>
			&one_d_knots_compute,
			std::ofstream &rules_stream, const unsigned &max_order)
{

  //============================================================
  /// Pre-calculate knots in 1D
  //============================================================

  std::vector<std::vector<double> > knot_1d(max_order+1);
  for(unsigned order=1; order<=max_order; order++)
    {
      double temp_weight[order], temp_knot[order];
      one_d_knots_compute(order,temp_knot,temp_weight);

      knot_1d[order].resize(order);
      for(unsigned i=0; i<order; i++)
	knot_1d[order][i] = temp_knot[i];
    }


  //=================================================================
  // Calculate + output knots in 1D
  //=================================================================

  // Output the knots (dimension 1)
  rules_stream << "{" <<std::endl
  	       << "{}," << std::endl;
  for(unsigned order=1; order<=max_order; order++)
    {
      // Dump knots
      rules_stream << "{";
      for(unsigned i=0; i<order; i++)
	rules_stream << knot_1d[order][i] << ",";
      rules_stream << "}," << std::endl;
    }
  rules_stream << "};" << std::endl
	       << std::endl;
}

int main()
{
  const unsigned max_order = 50;

  // Set up filename
  char filename[100];
  sprintf(filename,"VariableOrderQuadrature.cc");
  std::ofstream rules_stream;
  rules_stream.precision(16);
  rules_stream.open(filename);

  rules_stream << "// Automatically generated by generate_quadrature_rules_driver,"
	       << " based on QUADRULE." << std::endl
	       << "//See https://github.com/davidshepherd7/oomph-lib-additions/tree/master/generate_quadrature_rules ."
	       << std::endl;


  // List of functions to compute weights and knots With
  std::vector<std::string> class_name;
  std::vector<std::function<void(unsigned,double*,double*)> > function;

  class_name.push_back("VariableOrderGaussLegendre");
  function.push_back(legendre_dr_compute);

  class_name.push_back("VariableOrderClenshawCurtis");
  function.push_back(clenshaw_curtis_compute);

  class_name.push_back("VariableOrderFejerSecond");
  function.push_back(fejer2_compute);


  // Create and output to file the quadrature rules for all QElement schemes:
  for(unsigned i=0; i<function.size(); i++)
    {
      // Weights:
      rules_stream << "const " << class_name[i] << "::weights_data_structure" << std::endl
		   << class_name[i] << "::Weights =" << std::endl;
      quad_compute_weights(function[i], rules_stream, max_order);

      // Knots
      rules_stream << "const " << class_name[i] << "::knots_data_structure" << std::endl
		   << class_name[i] << "::Knots =" << std::endl;
      quad_compute_knots(function[i], rules_stream, max_order);
    }

  rules_stream.close();
}
