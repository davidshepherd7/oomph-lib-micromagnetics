Index: src/meshes/collapsible_channel_mesh.template.cc
===================================================================
--- src/meshes/collapsible_channel_mesh.template.cc	(revision 274)
+++ src/meshes/collapsible_channel_mesh.template.cc	(working copy)
@@ -157,7 +157,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(4,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Collapsible bit
@@ -167,7 +167,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(3,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
        
        // What column of elements are we in?
        unsigned ix=e-first_collapsible;
@@ -176,7 +176,7 @@
        zeta[0]=double(ix)*dzeta+double(i)*dzeta/double(nnode_1d-1);
        
        // Set boundary coordinate
-       this->finite_element_pt(e)->node_pt(2*nnode_1d+i)->
+       this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i)->
         set_coordinates_on_boundary(3,zeta);
       }
     }
@@ -187,7 +187,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(2,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Left end
Index: src/helmholtz/helmholtz_bc_elements.h
===================================================================
--- src/helmholtz/helmholtz_bc_elements.h	(revision 274)
+++ src/helmholtz/helmholtz_bc_elements.h	(working copy)
@@ -408,8 +408,8 @@
       
       //Get the nodal value of the helmholtz unknown
       const std::complex<double> u_value(
-       this->raw_nodal_value(l,this->U_index_helmholtz.real()),
-       this->raw_nodal_value(l,this->U_index_helmholtz.imag()));
+       this->raw_nodal_value(l,this->u_index_helmholtz().real()),
+       this->raw_nodal_value(l,this->u_index_helmholtz().imag()));
 
       //Add to the interpolated value
       interpolated_u += u_value*psi(l);         
@@ -732,8 +732,8 @@
       // Loop over real and imag part
       //Get the nodal value of the helmholtz unknown
       const std::complex<double> u_value(
-       this->raw_nodal_value(l,this->U_index_helmholtz.real()),
-       this->raw_nodal_value(l,this->U_index_helmholtz.imag()));
+       this->raw_nodal_value(l,this->u_index_helmholtz().real()),
+       this->raw_nodal_value(l,this->u_index_helmholtz().imag()));
 
       interpolated_u += u_value*psi[l];
 
@@ -753,9 +753,9 @@
       for(unsigned l=0;l<n_node;l++)
        {
         local_eqn_real = this->nodal_local_eqn
-         (l,this->U_index_helmholtz.real());
+	  (l,this->u_index_helmholtz().real());
         local_eqn_imag = this->nodal_local_eqn
-         (l,this->U_index_helmholtz.imag());
+	  (l,this->u_index_helmholtz().imag());
         
         // first, calculate the real part contrubution 
         //-----------------------    
@@ -775,10 +775,10 @@
             //Loop over the shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {     
-              local_unknown_real = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.real());
-              local_unknown_imag = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.imag());
+              local_unknown_real = this->nodal_local_eqn
+		(l2,this->u_index_helmholtz().real());
+              local_unknown_imag = this->nodal_local_eqn
+		(l2,this->u_index_helmholtz().imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
@@ -815,10 +815,10 @@
             //Loop over the shape functions again
             for(unsigned l2=0;l2<n_node;l2++)
              {     
-              local_unknown_real = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.real());
-              local_unknown_imag = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.imag());
+              local_unknown_real = this->nodal_local_eqn
+		(l2,this->u_index_helmholtz().real());
+              local_unknown_imag = this->nodal_local_eqn
+		(l2,this->u_index_helmholtz().imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
@@ -846,9 +846,9 @@
       for(unsigned l=0;l<n_node;l++)
        {
         local_eqn_real = this->nodal_local_eqn
-         (l,this->U_index_helmholtz.real());
+         (l,this->u_index_helmholtz().real());
         local_eqn_imag = this->nodal_local_eqn
-         (l,this->U_index_helmholtz.imag());
+         (l,this->u_index_helmholtz().imag());
          
         // first, calculate the real part contrubution 
         //-----------------------    
@@ -873,9 +873,9 @@
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.real());
+               l2,this->u_index_helmholtz().real());
               local_unknown_imag = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.imag());
+               l2,this->u_index_helmholtz().imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
@@ -919,9 +919,9 @@
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.real());
+               l2,this->u_index_helmholtz().real());
               local_unknown_imag = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.imag());
+               l2,this->u_index_helmholtz().imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
@@ -952,9 +952,9 @@
       for(unsigned l=0;l<n_node;l++)
        {
         local_eqn_real = this->nodal_local_eqn
-         (l,this->U_index_helmholtz.real());
+         (l,this->u_index_helmholtz().real());
         local_eqn_imag = this->nodal_local_eqn
-         (l,this->U_index_helmholtz.imag());
+         (l,this->u_index_helmholtz().imag());
          
         // first, calculate the real part contrubution 
         //-----------------------    
@@ -979,9 +979,9 @@
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.real());
+               l2,this->u_index_helmholtz().real());
               local_unknown_imag = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.imag());
+               l2,this->u_index_helmholtz().imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
@@ -1028,9 +1028,9 @@
             for(unsigned l2=0;l2<n_node;l2++)
              {     
               local_unknown_real = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.real());
+               l2,this->u_index_helmholtz().real());
               local_unknown_imag = this->nodal_local_eqn(
-               l2,this->U_index_helmholtz.imag());
+               l2,this->u_index_helmholtz().imag());
               //If at a non-zero degree of freedom add in the entry
               if(local_unknown_real >= 0)
                {
@@ -1239,9 +1239,9 @@
      for(unsigned l=0;l<n_node;l++)
       {
        local_eqn_real = this->nodal_local_eqn
-        (l,this->U_index_helmholtz.real());
+        (l,this->u_index_helmholtz().real());
        local_eqn_imag = this->nodal_local_eqn
-        (l,this->U_index_helmholtz.imag());
+        (l,this->u_index_helmholtz().imag());
        
        //IF it's not a boundary condition
        if(local_eqn_real >= 0)
@@ -1258,10 +1258,10 @@
             { 
              // Add the contribution of the local data
              local_unknown_real = this->nodal_local_eqn(
-              l2,this->U_index_helmholtz.real());
+              l2,this->u_index_helmholtz().real());
              
              local_unknown_imag = this->nodal_local_eqn(
-              l2,this->U_index_helmholtz.imag());
+              l2,this->u_index_helmholtz().imag());
              
              //If at a non-zero degree of freedom add in the entry
              if(local_unknown_real >= 0)
@@ -1289,10 +1289,10 @@
             { 
              // Add the contribution of the local data
              external_unknown_real = this->external_local_eqn(
-              l2,this->U_index_helmholtz.real());
+              l2,this->u_index_helmholtz().real());
              
              external_unknown_imag = this->external_local_eqn(
-              l2,this->U_index_helmholtz.imag());
+              l2,this->u_index_helmholtz().imag());
              
              //If at a non-zero degree of freedom add in the entry
              if(external_unknown_real >= 0)
@@ -1329,10 +1329,10 @@
             { 
              // Add the contribution of the local data
              local_unknown_real = this->nodal_local_eqn(
-              l2,this->U_index_helmholtz.real());
+              l2,this->u_index_helmholtz().real());
              
              local_unknown_imag = this->nodal_local_eqn(
-              l2,this->U_index_helmholtz.imag());
+              l2,this->u_index_helmholtz().imag());
 
              //If at a non-zero degree of freedom add in the entry
              if(local_unknown_real >= 0)
@@ -1360,10 +1360,10 @@
             { 
              // Add the contribution of the local data
              external_unknown_real = this->external_local_eqn(
-              l2,this->U_index_helmholtz.real());
+              l2,this->u_index_helmholtz().real());
              
              external_unknown_imag = this->external_local_eqn(
-              l2,this->U_index_helmholtz.imag());
+              l2,this->u_index_helmholtz().imag());
              
              //If at a non-zero degree of freedom add in the entry
              if(external_unknown_real >= 0)
@@ -1480,8 +1480,8 @@
       
       //Get the nodal value of the helmholtz unknown
       std::complex<double> u_value(
-       this->raw_nodal_value(l,this->U_index_helmholtz.real()),
-       this->raw_nodal_value(l,this->U_index_helmholtz.imag()));
+       this->raw_nodal_value(l,this->u_index_helmholtz().real()),
+       this->raw_nodal_value(l,this->u_index_helmholtz().imag()));
 
       interpolated_u += u_value*psi(l);
      } // End of loop over the nodes
@@ -1506,7 +1506,7 @@
      {
       // Add the contribution of the real local data
       local_unknown_real = this->nodal_local_eqn(
-       l,this->U_index_helmholtz.real());
+       l,this->u_index_helmholtz().real());
      if (local_unknown_real >= 0)
       {   
        global_unknown_real=this->eqn_number(local_unknown_real);
@@ -1516,7 +1516,7 @@
      
      // Add the contribution of the imag local data
      local_unknown_imag = this->nodal_local_eqn(
-      l,this->U_index_helmholtz.imag());
+      l,this->u_index_helmholtz().imag());
      if (local_unknown_imag >= 0)
       {   
        global_unknown_imag=this->eqn_number(local_unknown_imag);
Index: src/generic/double_multi_vector.h
===================================================================
--- src/generic/double_multi_vector.h	(revision 274)
+++ src/generic/double_multi_vector.h	(working copy)
@@ -471,7 +471,7 @@
  void redistribute(const LinearAlgebraDistribution* const& dist_pt);
    
  /// \short [] access function to the (local) values of the v-th vector
- double& operator()(int v, int i) const
+ double& operator()(unsigned v, unsigned i) const
   {
 #ifdef RANGE_CHECKING
    std::ostringstream error_message;
Index: src/generic/shape.h
===================================================================
--- src/generic/shape.h	(revision 274)
+++ src/generic/shape.h	(working copy)
@@ -78,7 +78,7 @@
 //=========================================================================
 class Shape
 {
-  private:
+protected:
 
  /// \short Pointer that addresses the storage that will be used to read and
  /// set the shape functions. The shape functions are packed into 
@@ -455,6 +455,41 @@
 
 };
 
+//======================================================================
+/// A shape function with a deep copy constructor. This allows for use with stl
+///  operations (e.g. manipulating vectors of shape functions). A seperate class
+///  is needed because the basic shape function uses a shallow copy.
+//======================================================================
+class ShapeWithDeepCopy : public Shape
+{
+public:
+
+  /// Constructor for a single-index set of shape functions.
+  ShapeWithDeepCopy(const unsigned &N) : Shape(N) {}
+
+  /// Constructor for a two-index set of shape functions.
+  ShapeWithDeepCopy(const unsigned &N, const unsigned &M) : Shape(N,M) {}
+
+  /// Default constructor
+  ShapeWithDeepCopy() : Shape() {}
+
+  /// Deep copy constructor
+  ShapeWithDeepCopy(const ShapeWithDeepCopy &old_shape) :
+    Shape(old_shape.Index1, old_shape.Index2)
+  {
+    for(unsigned i=0; i<Index1*Index2; i++)
+      Psi[i] = old_shape.Psi[i];
+  }
+
+  /// Broken assignment operator
+  void operator=(const ShapeWithDeepCopy &old_shape)
+  {BrokenCopy::broken_assign("ShapeWithDeepCopy");}
+
+ /// Destructor, clear up the memory allocated by the object
+ ~ShapeWithDeepCopy() {delete[] Allocated_storage; Allocated_storage=0;}
+
+};
+
 ////////////////////////////////////////////////////////////////////
 //
 // One dimensional shape functions and derivatives.
Index: src/generic/Makefile.am
===================================================================
--- src/generic/Makefile.am	(revision 274)
+++ src/generic/Makefile.am	(working copy)
@@ -99,7 +99,8 @@
 preconditioner.h \
 general_purpose_preconditioners.h block_preconditioner.h \
 general_purpose_block_preconditioners.h SuperLU_preconditioner.h \
-matrix_vector_product.h projection.h line_visualiser.h stacktrace.h
+matrix_vector_product.h projection.h line_visualiser.h stacktrace.h \
+cfortran.h
 
 if OOMPH_HAS_MUMPS
 headers+=mumps_solver.h
@@ -142,7 +143,7 @@
 
 # Need to worry about these for dependency but they shouldn't
 # be included into the include directory
-extra_headers = cfortran.h frontal.h arpack.h lapack_qz.h mumps.h
+extra_headers = frontal.h arpack.h lapack_qz.h mumps.h
 
 # Define name of library 
 libname = generic
Index: src/generic/elements.h
===================================================================
--- src/generic/elements.h	(revision 274)
+++ src/generic/elements.h	(working copy)
@@ -1221,7 +1221,7 @@
 
  /// \short Return the local equation number corresponding to the i-th
  /// value at the n-th local node.
- inline int nodal_local_eqn(const unsigned &n, const unsigned &i)
+ inline int nodal_local_eqn(const unsigned &n, const unsigned &i) const
   {
 #ifdef RANGE_CHECKING
    if(n >= Nnode)
Index: src/generic/elements.cc
===================================================================
--- src/generic/elements.cc	(revision 274)
+++ src/generic/elements.cc	(working copy)
@@ -3606,13 +3606,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -3681,13 +3679,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -4578,13 +4574,11 @@
      }
    }
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4666,13 +4660,11 @@
    }
 
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4829,9 +4821,7 @@
  
     //Calculate all derivatives of the spatial coordinates wrt 
     //local coordinates
-    DenseMatrix<double> interpolated_dxds(1,spatial_dim);
-    //Initialise to zero
-    for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(0,i) = 0.0;}
+    DenseMatrix<double> interpolated_dxds(1,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4882,10 +4872,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,spatial_dim);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4989,10 +4976,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,3);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<3;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,3,0.0);
     
     //Loop over all nodes
     for(unsigned l=0;l<n_node;l++)
@@ -6012,13 +5996,11 @@
    shape(s,psi);
 
    // Get Lagrangian coordinate
-   Vector<double> xi(n_lagrangian);
+   Vector<double> xi(n_lagrangian,0.0);
 
    //Loop over the number of lagrangian coordinates
    for(unsigned i=0;i<n_lagrangian;i++)
     {
-     //Initialise component to zero
-     xi[i] = 0.0;
      //Loop over the local nodes
      for(unsigned l=0;l<n_node;l++) 
       {
