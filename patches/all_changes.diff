Index: src/meshes/collapsible_channel_mesh.template.cc
===================================================================
--- src/meshes/collapsible_channel_mesh.template.cc	(revision 258)
+++ src/meshes/collapsible_channel_mesh.template.cc	(working copy)
@@ -157,7 +157,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(4,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Collapsible bit
@@ -167,7 +167,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(3,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
        
        // What column of elements are we in?
        unsigned ix=e-first_collapsible;
@@ -176,7 +176,7 @@
        zeta[0]=double(ix)*dzeta+double(i)*dzeta/double(nnode_1d-1);
        
        // Set boundary coordinate
-       this->finite_element_pt(e)->node_pt(2*nnode_1d+i)->
+       this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i)->
         set_coordinates_on_boundary(3,zeta);
       }
     }
@@ -187,7 +187,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(2,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Left end
Index: src/generic/shape.h
===================================================================
--- src/generic/shape.h	(revision 258)
+++ src/generic/shape.h	(working copy)
@@ -130,9 +130,18 @@
  Shape(const unsigned &N, const unsigned &M) : Index1(N), Index2(M) 
   {Allocated_storage = new double[N*M]; Psi = Allocated_storage;}
 
- /// Broken copy constructor
- Shape(const Shape &shape) {BrokenCopy::broken_copy("Shape");}
+  /// Default constructor to allow vectors of Shapes
+  Shape() {}
 
+  /// Deep copy constructor
+  Shape(const Shape &shape) : Index1(shape.Index1), Index2(shape.Index2)
+  {
+    Allocated_storage = new double[Index1*Index2];
+    Psi = Allocated_storage;
+    for(unsigned i=0; i<Index1*Index2; i++)
+      Psi[i] = shape.Psi[i];
+  }
+
  /// The assignment operator does a shallow copy 
  /// (resets the pointer to the data)
  void operator=(const Shape &shape)
Index: src/generic/Makefile.am
===================================================================
--- src/generic/Makefile.am	(revision 258)
+++ src/generic/Makefile.am	(working copy)
@@ -139,8 +139,11 @@
 
 # Need to worry about these for dependency but they shouldn't
 # be included into the include directory
-extra_headers = cfortran.h frontal.h arpack.h lapack_qz.h mumps.h
+extra_headers = frontal.h arpack.h lapack_qz.h mumps.h
 
+# Need fortran wrappers accesable from driver codes so add them to the nomal headers list (instead of "extra headers")
+headers += cfortran.h
+
 # Define name of library 
 libname = generic
 
Index: src/generic/elements.h
===================================================================
--- src/generic/elements.h	(revision 258)
+++ src/generic/elements.h	(working copy)
@@ -1107,7 +1107,7 @@
   private:
 
  /// Pointer to the spatial integration scheme
- Integral* Integral_pt;
+  Vector<Integral*> Integral_pt;
  
  /// Storage for pointers to the nodes in the element
  Node** Node_pt;
@@ -1221,7 +1221,7 @@
 
  /// \short Return the local equation number corresponding to the i-th
  /// value at the n-th local node.
- inline int nodal_local_eqn(const unsigned &n, const unsigned &i)
+  inline int nodal_local_eqn(const unsigned &n, const unsigned &i) const
   {
 #ifdef RANGE_CHECKING
    if(n >= Nnode)
@@ -1569,7 +1569,7 @@
  static bool Suppress_output_while_checking_for_inverted_elements;
 
  /// Constructor
- FiniteElement() : GeneralisedElement(), Integral_pt(0), 
+ FiniteElement() : GeneralisedElement(), Integral_pt(1),
   Node_pt(0), Nodal_local_eqn(0), Nnode(0),
   Elemental_dimension(0), Nodal_dimension(0), Nnodal_position_type(1),
   Macro_elem_pt(0) {}
@@ -1722,8 +1722,15 @@
  virtual void set_integration_scheme(Integral* const &integral_pt); 
 
  /// Return the pointer to the integration scheme (const version)
- Integral* const &integral_pt() const {return Integral_pt;}
+  Integral* const &integral_pt() const {return Integral_pt[0];}
  
+  ///Set the n'th spatial integration scheme
+  virtual void set_integration_scheme(Integral* const &integral_pt, const unsigned &n)
+  {Integral_pt[n] = integral_pt;}
+
+  /// Return the pointer to the n'th integration scheme
+  Integral* const &integral_pt(unsigned n) const {return Integral_pt[n];}
+
  /// \short Calculate the geometric shape functions 
  /// at local coordinate s. This function must be overloaded for each specific 
  /// geometric element.
Index: src/generic/elements.cc
===================================================================
--- src/generic/elements.cc	(revision 258)
+++ src/generic/elements.cc	(working copy)
@@ -2811,7 +2811,7 @@
  void FiniteElement::set_integration_scheme(Integral* const &integral_pt) 
  {
   //Assign the integration scheme
-  Integral_pt = integral_pt;
+  Integral_pt[0] = integral_pt;
  }
 
 //=========================================================================
@@ -3606,13 +3606,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -3681,13 +3679,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -4577,13 +4573,11 @@
      }
    }
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4828,9 +4822,7 @@
  
     //Calculate all derivatives of the spatial coordinates wrt 
     //local coordinates
-    DenseMatrix<double> interpolated_dxds(1,spatial_dim);
-    //Initialise to zero
-    for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(0,i) = 0.0;}
+    DenseMatrix<double> interpolated_dxds(1,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4881,10 +4873,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,spatial_dim);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4988,10 +4977,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,3);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<3;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,3,0.0);
     
     //Loop over all nodes
     for(unsigned l=0;l<n_node;l++)
