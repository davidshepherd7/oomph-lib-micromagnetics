Index: src/meshes/collapsible_channel_mesh.template.cc
===================================================================
--- src/meshes/collapsible_channel_mesh.template.cc	(revision 258)
+++ src/meshes/collapsible_channel_mesh.template.cc	(working copy)
@@ -157,7 +157,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(4,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Collapsible bit
@@ -167,7 +167,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(3,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
        
        // What column of elements are we in?
        unsigned ix=e-first_collapsible;
@@ -176,7 +176,7 @@
        zeta[0]=double(ix)*dzeta+double(i)*dzeta/double(nnode_1d-1);
        
        // Set boundary coordinate
-       this->finite_element_pt(e)->node_pt(2*nnode_1d+i)->
+       this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i)->
         set_coordinates_on_boundary(3,zeta);
       }
     }
@@ -187,7 +187,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(2,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Left end
Index: src/generic/shape.h
===================================================================
--- src/generic/shape.h	(revision 258)
+++ src/generic/shape.h	(working copy)
@@ -130,9 +130,18 @@
  Shape(const unsigned &N, const unsigned &M) : Index1(N), Index2(M) 
   {Allocated_storage = new double[N*M]; Psi = Allocated_storage;}
 
- /// Broken copy constructor
- Shape(const Shape &shape) {BrokenCopy::broken_copy("Shape");}
+  /// Default constructor to allow vectors of Shapes
+  Shape() {}
 
+  /// Deep copy constructor
+  Shape(const Shape &shape) : Index1(shape.Index1), Index2(shape.Index2)
+  {
+    Allocated_storage = new double[Index1*Index2];
+    Psi = Allocated_storage;
+    for(unsigned i=0; i<Index1*Index2; i++)
+      Psi[i] = shape.Psi[i];
+  }
+
  /// The assignment operator does a shallow copy 
  /// (resets the pointer to the data)
  void operator=(const Shape &shape)
Index: src/generic/Makefile.am
===================================================================
--- src/generic/Makefile.am	(revision 258)
+++ src/generic/Makefile.am	(working copy)
@@ -96,7 +96,8 @@
 preconditioner.h \
 general_purpose_preconditioners.h block_preconditioner.h \
 general_purpose_block_preconditioners.h SuperLU_preconditioner.h \
-matrix_vector_product.h projection.h line_visualiser.h stacktrace.h
+matrix_vector_product.h projection.h line_visualiser.h stacktrace.h \
+cfortran.h
 
 if OOMPH_HAS_MUMPS
 headers+=mumps_solver.h
@@ -139,7 +140,7 @@
 
 # Need to worry about these for dependency but they shouldn't
 # be included into the include directory
-extra_headers = cfortran.h frontal.h arpack.h lapack_qz.h mumps.h
+extra_headers = frontal.h arpack.h lapack_qz.h mumps.h
 
 # Define name of library 
 libname = generic
Index: src/generic/elements.cc
===================================================================
--- src/generic/elements.cc	(revision 258)
+++ src/generic/elements.cc	(working copy)
@@ -3606,13 +3606,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -3681,13 +3679,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -4577,13 +4573,11 @@
      }
    }
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4665,13 +4659,11 @@
    }
 
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4828,9 +4820,7 @@
  
     //Calculate all derivatives of the spatial coordinates wrt 
     //local coordinates
-    DenseMatrix<double> interpolated_dxds(1,spatial_dim);
-    //Initialise to zero
-    for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(0,i) = 0.0;}
+    DenseMatrix<double> interpolated_dxds(1,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4881,10 +4871,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,spatial_dim);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4988,10 +4975,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,3);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<3;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,3,0.0);
     
     //Loop over all nodes
     for(unsigned l=0;l<n_node;l++)
@@ -6011,13 +5995,11 @@
    shape(s,psi);
 
    // Get Lagrangian coordinate
-   Vector<double> xi(n_lagrangian);
+   Vector<double> xi(n_lagrangian,0.0);
 
    //Loop over the number of lagrangian coordinates
    for(unsigned i=0;i<n_lagrangian;i++)
     {
-     //Initialise component to zero
-     xi[i] = 0.0;
      //Loop over the local nodes
      for(unsigned l=0;l<n_node;l++) 
       {
