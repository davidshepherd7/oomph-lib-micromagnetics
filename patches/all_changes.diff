Index: src/meshes/collapsible_channel_mesh.template.cc
===================================================================
--- src/meshes/collapsible_channel_mesh.template.cc	(revision 274)
+++ src/meshes/collapsible_channel_mesh.template.cc	(working copy)
@@ -157,7 +157,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(4,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Collapsible bit
@@ -167,7 +167,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(3,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
        
        // What column of elements are we in?
        unsigned ix=e-first_collapsible;
@@ -176,7 +176,7 @@
        zeta[0]=double(ix)*dzeta+double(i)*dzeta/double(nnode_1d-1);
        
        // Set boundary coordinate
-       this->finite_element_pt(e)->node_pt(2*nnode_1d+i)->
+       this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i)->
         set_coordinates_on_boundary(3,zeta);
       }
     }
@@ -187,7 +187,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(2,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Left end
Index: src/generic/double_multi_vector.h
===================================================================
--- src/generic/double_multi_vector.h	(revision 274)
+++ src/generic/double_multi_vector.h	(working copy)
@@ -471,7 +471,7 @@
  void redistribute(const LinearAlgebraDistribution* const& dist_pt);
    
  /// \short [] access function to the (local) values of the v-th vector
- double& operator()(int v, int i) const
+ double& operator()(unsigned v, unsigned i) const
   {
 #ifdef RANGE_CHECKING
    std::ostringstream error_message;
Index: src/generic/shape.h
===================================================================
--- src/generic/shape.h	(revision 274)
+++ src/generic/shape.h	(working copy)
@@ -78,7 +78,7 @@
 //=========================================================================
 class Shape
 {
-  private:
+protected:
 
  /// \short Pointer that addresses the storage that will be used to read and
  /// set the shape functions. The shape functions are packed into 
@@ -133,6 +133,10 @@
  /// Broken copy constructor
  Shape(const Shape &shape) {BrokenCopy::broken_copy("Shape");}
 
+ /// Default constructor - just assigns a null pointer for the storage so that
+ /// the destructor works as expected.
+ Shape() : Allocated_storage(0) {}
+
  /// The assignment operator does a shallow copy 
  /// (resets the pointer to the data)
  void operator=(const Shape &shape)
@@ -455,6 +459,41 @@
 
 };
 
+//======================================================================
+/// A shape function with a deep copy constructor. This allows for use with stl
+///  operations (e.g. manipulating vectors of shape functions). A seperate class
+///  is needed because the basic shape function uses a shallow copy.
+//======================================================================
+class ShapeWithDeepCopy : public Shape
+{
+public:
+
+  /// Constructor for a single-index set of shape functions.
+  ShapeWithDeepCopy(const unsigned &N) : Shape(N) {}
+
+  /// Constructor for a two-index set of shape functions.
+  ShapeWithDeepCopy(const unsigned &N, const unsigned &M) : Shape(N,M) {}
+
+  /// Default constructor
+  ShapeWithDeepCopy() : Shape() {}
+
+  /// Deep copy constructor
+  ShapeWithDeepCopy(const ShapeWithDeepCopy &old_shape) :
+    Shape(old_shape.Index1, old_shape.Index2)
+  {
+    for(unsigned i=0; i<Index1*Index2; i++)
+      Psi[i] = old_shape.Psi[i];
+  }
+
+  /// Broken assignment operator
+  void operator=(const ShapeWithDeepCopy &old_shape)
+  {BrokenCopy::broken_assign("ShapeWithDeepCopy");}
+
+ /// Destructor, clear up the memory allocated by the object
+ ~ShapeWithDeepCopy() {delete[] Allocated_storage; Allocated_storage=0;}
+
+};
+
 ////////////////////////////////////////////////////////////////////
 //
 // One dimensional shape functions and derivatives.
Index: src/generic/Makefile.am
===================================================================
--- src/generic/Makefile.am	(revision 274)
+++ src/generic/Makefile.am	(working copy)
@@ -99,7 +99,8 @@
 preconditioner.h \
 general_purpose_preconditioners.h block_preconditioner.h \
 general_purpose_block_preconditioners.h SuperLU_preconditioner.h \
-matrix_vector_product.h projection.h line_visualiser.h stacktrace.h
+matrix_vector_product.h projection.h line_visualiser.h stacktrace.h \
+cfortran.h
 
 if OOMPH_HAS_MUMPS
 headers+=mumps_solver.h
@@ -142,7 +143,7 @@
 
 # Need to worry about these for dependency but they shouldn't
 # be included into the include directory
-extra_headers = cfortran.h frontal.h arpack.h lapack_qz.h mumps.h
+extra_headers = frontal.h arpack.h lapack_qz.h mumps.h
 
 # Define name of library 
 libname = generic
Index: src/generic/elements.h
===================================================================
--- src/generic/elements.h	(revision 274)
+++ src/generic/elements.h	(working copy)
@@ -1221,7 +1221,7 @@
 
  /// \short Return the local equation number corresponding to the i-th
  /// value at the n-th local node.
- inline int nodal_local_eqn(const unsigned &n, const unsigned &i)
+ inline int nodal_local_eqn(const unsigned &n, const unsigned &i) const
   {
 #ifdef RANGE_CHECKING
    if(n >= Nnode)
Index: src/generic/elements.cc
===================================================================
--- src/generic/elements.cc	(revision 274)
+++ src/generic/elements.cc	(working copy)
@@ -3606,13 +3606,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -3681,13 +3679,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -4578,13 +4574,11 @@
      }
    }
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4666,13 +4660,11 @@
    }
 
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4829,9 +4821,7 @@
  
     //Calculate all derivatives of the spatial coordinates wrt 
     //local coordinates
-    DenseMatrix<double> interpolated_dxds(1,spatial_dim);
-    //Initialise to zero
-    for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(0,i) = 0.0;}
+    DenseMatrix<double> interpolated_dxds(1,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4882,10 +4872,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,spatial_dim);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4989,10 +4976,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,3);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<3;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,3,0.0);
     
     //Loop over all nodes
     for(unsigned l=0;l<n_node;l++)
@@ -6012,13 +5996,11 @@
    shape(s,psi);
 
    // Get Lagrangian coordinate
-   Vector<double> xi(n_lagrangian);
+   Vector<double> xi(n_lagrangian,0.0);
 
    //Loop over the number of lagrangian coordinates
    for(unsigned i=0;i<n_lagrangian;i++)
     {
-     //Initialise component to zero
-     xi[i] = 0.0;
      //Loop over the local nodes
      for(unsigned l=0;l<n_node;l++) 
       {
