Index: src/meshes/collapsible_channel_mesh.template.cc
===================================================================
--- src/meshes/collapsible_channel_mesh.template.cc	(revision 274)
+++ src/meshes/collapsible_channel_mesh.template.cc	(working copy)
@@ -157,7 +157,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(4,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Collapsible bit
@@ -167,7 +167,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(3,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
        
        // What column of elements are we in?
        unsigned ix=e-first_collapsible;
@@ -176,7 +176,7 @@
        zeta[0]=double(ix)*dzeta+double(i)*dzeta/double(nnode_1d-1);
        
        // Set boundary coordinate
-       this->finite_element_pt(e)->node_pt(2*nnode_1d+i)->
+       this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i)->
         set_coordinates_on_boundary(3,zeta);
       }
     }
@@ -187,7 +187,7 @@
      for (unsigned i=0;i<nnode_1d;i++)
       {
        add_boundary_node(2,
-                         this->finite_element_pt(e)->node_pt(2*nnode_1d+i));
+                         this->finite_element_pt(e)->node_pt((nnode_1d-1)*nnode_1d+i));
       }
     }
    // Left end
Index: src/generic/matrices.h
===================================================================
--- src/generic/matrices.h	(revision 274)
+++ src/generic/matrices.h	(working copy)
@@ -790,7 +790,16 @@
                 const Vector<int>& column_index,
                 const Vector<int>& row_start);
 
- /// \short Constructor: just stores the distribution but does not build the
+    /// Construct a cr matrix from vectors of values, column index and row index
+    /// (this is mostly for convenience while testing or playing with this type of
+    /// matrix).
+    // I haven't made this distributable since I don't know how.
+    CRDoubleMatrix(const Vector<double>& values,
+		   const Vector<int>& row_indices,
+		   const Vector<int>& col_indices,
+		   const unsigned& nrow, const unsigned& ncol);
+
+    // \short Constructor: just stores the distribution but does not build the
  /// matrix
  CRDoubleMatrix(const LinearAlgebraDistribution* distribution_pt);
  
@@ -2974,6 +2983,19 @@
                         const unsigned long &n,
                         const unsigned long &m)
 {
+#ifdef PARANOID
+    if(value.size() != column_index_.size())
+      {
+	std::ostringstream error_message;
+	error_message << "Must have the same number of values and column indicies,"
+		      << "we have " << value.size() << " values and "
+		      << column_index_.size() << " column inidicies."
+		      << std::endl;
+	throw OomphLibError(error_message.str(),"CRMatrix<T>::build",
+			    OOMPH_EXCEPTION_LOCATION);
+      }
+#endif
+
  // Number of nonzero entries
  this->Nnz = value.size();
  
@@ -3020,10 +3042,162 @@
 template<class T,class MATRIX_TYPE>
  T SparseMatrix<T,MATRIX_TYPE>::Zero=T(0);
 
+
+  //======================================================================
+  /// Class for a matrix of the form M = S + G + H + ... where S is the main
+  /// matrix and G,H etc. are matrices of size S or smaller.  This may be useful
+  /// if, for example, G,H etc. are subblocks of M that must be stored in a
+  /// different format to S.
+
+  /// Maps mut be provided which gives a map from the rows/cols of the "main"
+  /// matrix to the rows/cols of each of the added matrices.
+  //======================================================================
+  class SumOfMatrices : public DoubleMatrixBase
+  {
+
+  private:
+
+
+    typedef std::map<long unsigned, long unsigned> index_map;
+
+    // Pointer to the matrix which we are adding the others to
+    DoubleMatrixBase* Main_matrix_pt;
+
+    // List of pointers to the matrices that are added to the main matrix
+    Vector<DoubleMatrixBase*> Added_matrix_pt;
+
+    // List of maps from the row numbers of the main matrix to the added matrix
+    // row numbers.
+    Vector<index_map* > Main_to_individual_rows_pt;
+
+    // List of maps from the col numbers of the main matrix to the added matrix
+    // col numbers.
+    Vector<index_map* > Main_to_individual_cols_pt;
+
+    // Should we delete the sub matrices when destructor is called?
+    Vector<unsigned> Should_delete_matrix;
+
+    /// Should we delete the main matrix when destructor is called? Default is
+    /// no.
+    bool Should_delete_main_matrix;
+
+  public:
+
+    /// Default constructor
+    SumOfMatrices()
+      : Main_matrix_pt(0), Added_matrix_pt(0),
+	Main_to_individual_rows_pt(0), Main_to_individual_cols_pt(0),
+	Should_delete_matrix(0), Should_delete_main_matrix(0) {}
+
+    /// Broken copy constructor
+    SumOfMatrices(const SumOfMatrices& matrix)
+    {BrokenCopy::broken_copy("SumOfMatrices");}
+
+    /// Broken assignment operator
+    void operator=(const SumOfMatrices&)
+    {BrokenCopy::broken_assign("SumOfMatrices");}
+
+    /// Destructor: delete matrices as instructed by Should_delete_matrix vector
+    virtual ~SumOfMatrices()
+    {
+      for(unsigned i_matrix=0; i_matrix<Added_matrix_pt.size(); i_matrix++)
+	{
+	  if(Should_delete_matrix[i_matrix] == 1)
+	    delete Added_matrix_pt[i_matrix];
 }
 
+      if(Should_delete_main_matrix)
+	delete Main_matrix_pt;
+    }
+
+    /// Access to the main matrix
+    const DoubleMatrixBase* main_matrix_pt() const {return Main_matrix_pt;}
+    DoubleMatrixBase*& main_matrix_pt() {return Main_matrix_pt;}
+
+    void set_delete_main_matrix()
+    {Should_delete_main_matrix = true;}
+
+    // Add a new matrix to the sum by giving a matrix pointer and a mapping from
+    // the main matrix numbering to the new matrix numbering.
+    void add_matrix(DoubleMatrixBase* added_matrix_pt_in,
+		    index_map* const main_to_individual_rows_pt,
+		    index_map* const main_to_individual_cols_pt,
+		    bool should_delete_matrix=false)
+    {
+#ifdef RANGE_CHECKING
+      if (main_to_individual_rows_pt->size() != added_matrix_pt_in->nrow())
+	{
+	  throw OomphLibError("Row mapping should be of size nrow.",
+			      "SumOfMatrices::add_matrix",
+			      OOMPH_EXCEPTION_LOCATION);
+	}
+
+      if (main_to_individual_cols_pt->size() != added_matrix_pt_in->ncol())
+	{
+	  throw OomphLibError("Col mapping should be of size ncol.",
+			      "SumOfMatrices::add_matrix",
+			      OOMPH_EXCEPTION_LOCATION);
+	}
 #endif
 
+      Added_matrix_pt.push_back(added_matrix_pt_in);
+      Main_to_individual_rows_pt.push_back(main_to_individual_rows_pt);
+      Main_to_individual_cols_pt.push_back(main_to_individual_cols_pt);
+      Should_delete_matrix.push_back(unsigned(should_delete_matrix));
+    }
 
+    // Access functions
+    inline DoubleMatrixBase* added_matrix_pt(const unsigned& i) const
+    {return Added_matrix_pt[i];}
 
+    /// Return the number of rows of the total matrix (equal to that of the first
+    /// matrix).
+    inline unsigned long nrow() const
+    {
+#ifdef PARANOID
+      if(Main_matrix_pt==0)
+	{
+	  OomphLibError("Main_matrix_pt not set","SumOfMatrices::nrow()",
+			OOMPH_EXCEPTION_LOCATION);
+	}
+#endif
+      return Main_matrix_pt->nrow();
+    }
 
+    /// Return the number of columns of the total matrix (equal to that of the
+    /// first matrix).
+    inline unsigned long ncol() const {return Main_matrix_pt->ncol();}
+
+    /// Return the number of matrices in the sum
+    inline unsigned nmatrix() const {return Added_matrix_pt.size() + 1;}
+
+    /// Multiply: just call multiply on each of the matrices and add up the
+    /// results (with appropriate bookeeping of the relative positions).
+    void multiply(const DoubleVector &x, DoubleVector &soln) const;
+
+    //======================================================================
+    /// Broken write operator() because it does not make sense to write to a sum
+    /// of matrices. Need to change the individual matrices within the sum
+    /// instead.
+    //======================================================================
+    const double& operator()(const unsigned long& i, const unsigned long& j) const
+    {
+      throw OomphLibError("Broken write operator() for SumOfMatrices matrix class: it does not make sense to write to a sum of matrices. You need to write to the individual matrices within the sum instead.",
+			  "non-constant SumOfMatrices::operator()",
+			  OOMPH_EXCEPTION_LOCATION);
+    }
+
+    void multiply_transpose(const DoubleVector &x, DoubleVector &soln) const
+    {
+      // Should just work like multiply with all lower calls replaced by multiply
+      // transpose. Might also need to change the row/columns used for the
+      // temporary x and/or soln.
+      throw OomphLibError("Not yet implemented.",
+			  "SumOfMatrices::multiply_transpose",
+			  OOMPH_EXCEPTION_LOCATION);
+    }
+
+  };
+
+}
+#endif
Index: src/generic/eigen_solver.cc
===================================================================
--- src/generic/eigen_solver.cc	(revision 274)
+++ src/generic/eigen_solver.cc	(working copy)
@@ -543,6 +543,9 @@
    //N.B. This is naive and dangerous according to the documentation
    //beta could be very small giving over or under flow
    //Remember to fix the shift back again
+
+    // Should there be a PARANOID check here then? I'm not going to add one
+    // because I don't understand what's going on - DS.
    eigenvalue[i] = 
     std::complex<double>(sigmar + alpha_r[i]/beta[i],alpha_i[i]/beta[i]);
 
@@ -567,7 +570,7 @@
 
 
 //==========================================================================
-/// Use LAPACK to solve an complex eigen problem specified by the given
+/// Use LAPACK to solve a complex eigen problem specified by the given
 /// given matrices
 //==========================================================================
 void LAPACK_QZ::find_eigenvalues(const ComplexMatrixBase &A,
Index: src/generic/problem.cc
===================================================================
--- src/generic/problem.cc	(revision 274)
+++ src/generic/problem.cc	(working copy)
@@ -81,7 +81,8 @@
   Numerical_zero_for_sparse_assembly(0.0),
   Mass_matrix_reuse_is_enabled(false), Mass_matrix_has_been_computed(false),
   Discontinuous_element_formulation(false),
-  Minimum_dt(1.0e-12), Maximum_dt(1.0e12), DTSF_max_increase(4.0),
+  Minimum_dt(1.0e-12), Maximum_dt(1.0e12),
+  DTSF_max_increase(4.0),
   Minimum_dt_but_still_proceed(-1.0),
   Scale_arc_length(true), Desired_proportion_of_arc_length(0.5),
   Theta_squared(1.0), Sign_of_jacobian(0), Continuation_direction(1.0), 
@@ -1914,18 +1915,6 @@
    for(unsigned i=0;i<Nglobal_data;i++)
     {Global_data_pt[i]->assign_eqn_numbers(equation_number,Dof_pt);}
    
-   //Check that the Mesh_pt has been assigned
-   if(Mesh_pt==0)
-    {
-     std::string error_message =
-      "(Global) Mesh_pt must be assigned before calling ";
-     error_message += " assign_eqn_numbers()\n";
-     
-     throw OomphLibError(error_message,
-                         "Problem::assign_eqn_numbers()",
-                         OOMPH_EXCEPTION_LOCATION);
-    }
-   
    if (Global_timings::Doc_comprehensive_timings)
     {
      t_start = TimingHelpers::timer();
@@ -9482,7 +9471,7 @@
  //The value of the actual timestep, by default the same as desired timestep
  double dt_actual=dt_desired;
  //Timestep rescaling factor, 1.0 by default
- double DTSF = 1.0;
+ double dt_rescaling_factor = 1.0;
  
  //Determine the number of timesteppers
  unsigned n_time_steppers = ntime_stepper();
@@ -9610,10 +9599,10 @@
      double error = global_temporal_error_norm(); 
 
      //Calculate the scaling  factor
-     DTSF = pow((epsilon/error),
+     dt_rescaling_factor = pow((epsilon/error),
                 (1.0/(1.0+time_stepper_pt()->order())));
      
-     oomph_info << "DTSF is  " << DTSF << std::endl;
+     oomph_info << "Timestep scaling factor is  " << dt_rescaling_factor << std::endl;
      oomph_info << "Estimated timestepping error is " << error << std::endl;
      
      
@@ -9622,9 +9611,9 @@
      
      // Impose lower bound on timestep (i.e. accept timestep
      // even though tolerance isn't satisfied)
-     if(DTSF <= dtsf_threshold)
+     if(dt_rescaling_factor <= dtsf_threshold)
       {
-       double new_timestep=dt_actual*DTSF;
+       double new_timestep=dt_actual*dt_rescaling_factor;
        
        if (new_timestep<Minimum_dt_but_still_proceed)
         {
@@ -9635,19 +9624,19 @@
           << "         Problem::Minimum_dt_but_still_proceed="
           <<           Minimum_dt_but_still_proceed << "\n"
           << "         ---> We're continuing with present timestep.\n";
-         DTSF=1.0;
+         dt_rescaling_factor=1.0;
         }
       }
      
-     //Now decide what to do based upon DTSF
+     //Now decide what to do based upon dt_rescaling_factor
      //If it's small reject the timestep
-     if(DTSF <= dtsf_threshold)
+     if(dt_rescaling_factor <= dtsf_threshold)
       {
        oomph_info << "TIMESTEP REJECTED" << std::endl;
        //Reject the timestep
        REJECT_TIMESTEP=1;
        //Modify the actual timestep
-       dt_actual *= DTSF;
+       dt_actual *= dt_rescaling_factor;
        //Reset the time
        time_pt()->time() = time_current;
        //Reload the dofs
@@ -9667,13 +9656,14 @@
        continue;
       }
      //If it's large change the timestep
-     if(DTSF >= 1.0)
+     if(dt_rescaling_factor >= 1.0)
       {
        //Restrict the increase
-       if(DTSF > DTSF_max_increase)
+       if(dt_rescaling_factor > DTSF_max_increase)
         {
-         DTSF = DTSF_max_increase;
-         oomph_info << "DTSF LIMITED TO " << DTSF_max_increase << std::endl;
+         dt_rescaling_factor = DTSF_max_increase;
+         oomph_info << "TIMESTEP SCALING FACTOR LIMITED TO "
+		    << DTSF_max_increase << std::endl;
         }
       }
 
@@ -9685,19 +9675,19 @@
 
 
  //Make sure timestep doesn't get too large
- if ((dt_actual*DTSF) > Maximum_dt)
+ if ((dt_actual*dt_rescaling_factor) > Maximum_dt)
   {
-   oomph_info << "DTSF WOULD INCREASE TIMESTEP "
+   oomph_info << "TIMESTEP SCALING WOULD INCREASE TIMESTEP "
               << "ABOVE SPECIFIED THRESHOLD: Problem::Maximum_dt=" 
               <<  Maximum_dt << std::endl;
-   DTSF =  Maximum_dt/dt_actual;
-   oomph_info << "ADJUSTING DTSF TO " << DTSF << std::endl;
+   dt_rescaling_factor =  Maximum_dt/dt_actual;
+   oomph_info << "ADJUSTING TIMESTEP SCALING FACTOR TO " << dt_rescaling_factor << std::endl;
   }
  
 
  //Once the timestep has been accepted, return the actual timestep taken, 
  //suitably scaled, to be used the next time
- return (dt_actual*DTSF);
+ return (dt_actual*dt_rescaling_factor);
 }
 
 
Index: src/generic/double_multi_vector.h
===================================================================
--- src/generic/double_multi_vector.h	(revision 274)
+++ src/generic/double_multi_vector.h	(working copy)
@@ -471,7 +471,7 @@
  void redistribute(const LinearAlgebraDistribution* const& dist_pt);
    
  /// \short [] access function to the (local) values of the v-th vector
- double& operator()(int v, int i) const
+ double& operator()(unsigned v, unsigned i) const
   {
 #ifdef RANGE_CHECKING
    std::ostringstream error_message;
Index: src/generic/block_preconditioner.h
===================================================================
--- src/generic/block_preconditioner.h	(revision 274)
+++ src/generic/block_preconditioner.h	(working copy)
@@ -329,8 +329,6 @@
      Ndof_types_in_mesh[i] = ndof_types_in_mesh;
     }
 
-    protected:
-
    /// \short Determine the size of the matrix blocks and setup the
    /// lookup schemes relating the global degrees of freedom with
    /// their "blocks" and their indices (row/column numbers) in those
@@ -1482,21 +1480,29 @@
        // elements -- their blocks are added one after the other...
        unsigned dof_offset=0;
 
+
+       // std::cout << "Begin looping through meshes: " << std::endl;
        // Loop over all meshes
        for (unsigned m=0;m<Nmesh;m++)
         {
          // Number of elements in this mesh
          unsigned n_element = this->Mesh_pt[m]->nelement();
 
+ 	 // std::cout << "\n\nmesh no.: " << m << ", n_element: " << n_element << std::endl;
          // Find the number of block types that the elements in this mesh
          // are in charge of
          unsigned ndof_in_element=Ndof_types_in_mesh[m];
          Ndof_types += ndof_in_element;
 
+         // std::cout << "ndof_in_element: " << ndof_in_element;
+         // std::cout << ", Ndof so far: " << Ndof_types << std::endl;
          // Loop over all elements
+
+         // std::cout << "Begin loop over elements: " << std::endl;
+
          for (unsigned e=0;e<n_element;e++)
           {
-
+           // std::cout << "ele no.: " << e << std::endl;
            // List containing pairs of global equation number and
            // dof number for each global dof in an element
            std::list<std::pair<unsigned long,unsigned> > dof_lookup_list;
@@ -1516,20 +1522,28 @@
              if (global_dof >= unsigned(first_row) &&
                  global_dof <= unsigned(last_row))
               {
+               // std::cout <<"BP geqn: " << global_dof;
                unsigned dof_number = (it->second)+dof_offset;
+               // std::cout << ", doftype: " << dof_number;
                Dof_number_dense[global_dof-first_row] 
                 = dof_number;
                
-#ifdef PARANOID
+               // std::cout<<", BPgeqn - first_row: " << global_dof << " - "
+	       // << first_row << " = " << (global_dof - first_row) << std::endl;
+
+//*#ifdef PARANOID
                // Check consistency of block numbers if assigned multiple times
                if (previously_assigned_block_number[global_dof-
                                                     first_row]<0)
                 {
+                  // RRR std::cout << " got in if! "<< std::endl;
                  previously_assigned_block_number[global_dof-first_row]
                   =dof_number;
                 }
                else
                 {
+                  /*
+                  // std::cout << " got in else!" << std::endl;
                  if (previously_assigned_block_number[global_dof
                                                       -first_row]!=
                      int(dof_number))
@@ -1555,12 +1569,14 @@
                    throw OomphLibWarning(error_message.str(),
                                          "BlockPreconditioner::nblock_types()",
                                          OOMPH_EXCEPTION_LOCATION);
+                  }//if warning if the re-classification is not the same...
+                  */
+                } // else
+//#endif
+//*/
                   }
                 }
-#endif
               }
-            }
-          }
 
          // About to do the next mesh which contains block preconditionable
          // elements of a different type; all the dofs that these elements are
@@ -1577,6 +1593,8 @@
         {
          if (previously_assigned_block_number[i] < 0)
           {
+           // std::cout << "geqn: " << i << " is not assigned. "<< std::endl;
+           pause("Ho hum.");
            success = false;
           }
         }
Index: src/generic/shape.h
===================================================================
--- src/generic/shape.h	(revision 274)
+++ src/generic/shape.h	(working copy)
@@ -78,7 +78,7 @@
 //=========================================================================
 class Shape
 {
-  private:
+protected:
 
  /// \short Pointer that addresses the storage that will be used to read and
  /// set the shape functions. The shape functions are packed into 
@@ -133,6 +133,10 @@
  /// Broken copy constructor
  Shape(const Shape &shape) {BrokenCopy::broken_copy("Shape");}
 
+ /// Default constructor - just assigns a null pointer for the storage so that
+ /// the destructor works as expected.
+ Shape() : Allocated_storage(0) {}
+
  /// The assignment operator does a shallow copy 
  /// (resets the pointer to the data)
  void operator=(const Shape &shape)
@@ -455,6 +459,41 @@
 
 };
 
+//======================================================================
+/// A shape function with a deep copy constructor. This allows for use with stl
+///  operations (e.g. manipulating vectors of shape functions). A seperate class
+///  is needed because the basic shape function uses a shallow copy.
+//======================================================================
+class ShapeWithDeepCopy : public Shape
+{
+public:
+
+  /// Constructor for a single-index set of shape functions.
+  ShapeWithDeepCopy(const unsigned &N) : Shape(N) {}
+
+  /// Constructor for a two-index set of shape functions.
+  ShapeWithDeepCopy(const unsigned &N, const unsigned &M) : Shape(N,M) {}
+
+  /// Default constructor
+  ShapeWithDeepCopy() : Shape() {}
+
+  /// Deep copy constructor
+  ShapeWithDeepCopy(const ShapeWithDeepCopy &old_shape) :
+    Shape(old_shape.Index1, old_shape.Index2)
+  {
+    for(unsigned i=0; i<Index1*Index2; i++)
+      Psi[i] = old_shape.Psi[i];
+  }
+
+  /// Broken assignment operator
+  void operator=(const ShapeWithDeepCopy &old_shape)
+  {BrokenCopy::broken_assign("ShapeWithDeepCopy");}
+
+ /// Destructor, clear up the memory allocated by the object
+ ~ShapeWithDeepCopy() {delete[] Allocated_storage; Allocated_storage=0;}
+
+};
+
 ////////////////////////////////////////////////////////////////////
 //
 // One dimensional shape functions and derivatives.
Index: src/generic/Makefile.am
===================================================================
--- src/generic/Makefile.am	(revision 274)
+++ src/generic/Makefile.am	(working copy)
@@ -99,7 +99,8 @@
 preconditioner.h \
 general_purpose_preconditioners.h block_preconditioner.h \
 general_purpose_block_preconditioners.h SuperLU_preconditioner.h \
-matrix_vector_product.h projection.h line_visualiser.h stacktrace.h
+matrix_vector_product.h projection.h line_visualiser.h stacktrace.h \
+cfortran.h
 
 if OOMPH_HAS_MUMPS
 headers+=mumps_solver.h
@@ -142,7 +143,7 @@
 
 # Need to worry about these for dependency but they shouldn't
 # be included into the include directory
-extra_headers = cfortran.h frontal.h arpack.h lapack_qz.h mumps.h
+extra_headers = frontal.h arpack.h lapack_qz.h mumps.h
 
 # Define name of library 
 libname = generic
Index: src/generic/matrices.cc
===================================================================
--- src/generic/matrices.cc	(revision 274)
+++ src/generic/matrices.cc	(working copy)
@@ -430,30 +430,30 @@
                        "DenseDoubleMatrix::multiply()",
                        OOMPH_EXCEPTION_LOCATION);
   }
- // check that x is not distributed
- if (x.distributed())
-  {
-   std::ostringstream error_message_stream;
-   error_message_stream 
-    << "The x vector cannot be distributed for DenseDoubleMatrix "
-    << "matrix-vector multiply" << std::endl;
-   throw OomphLibError(error_message_stream.str(),
-                       "DenseDoubleMatrix::multiply()",
-                       OOMPH_EXCEPTION_LOCATION);
-  }
+ // // check that x is not distributed
+ // if (x.distributed())
+ //  {
+ //   std::ostringstream error_message_stream;
+ //   error_message_stream
+ //    << "The x vector cannot be distributed for DenseDoubleMatrix "
+ //    << "matrix-vector multiply" << std::endl;
+ //   throw OomphLibError(error_message_stream.str(),
+ //                       "DenseDoubleMatrix::multiply()",
+ //                       OOMPH_EXCEPTION_LOCATION);
+ //  }
  // if soln is setup...
  if (soln.built())
   {
    // check that soln is not distributed
    if (soln.distributed())
     {
-     std::ostringstream error_message_stream;
-     error_message_stream 
-      << "The x vector cannot be distributed for DenseDoubleMatrix "
-      << "matrix-vector multiply" << std::endl;
-     throw OomphLibError(error_message_stream.str(),
-                         "DenseDoubleMatrix::multiply()",
-                         OOMPH_EXCEPTION_LOCATION);
+     // std::ostringstream error_message_stream;
+     // error_message_stream
+     //  << "The x vector cannot be distributed for DenseDoubleMatrix "
+     //  << "matrix-vector multiply" << std::endl;
+     // throw OomphLibError(error_message_stream.str(),
+     //                     "DenseDoubleMatrix::multiply()",
+     //                     OOMPH_EXCEPTION_LOCATION);
     }
    if (soln.nrow() != this->nrow())
     {
@@ -482,11 +482,9 @@
  // if soln is not setup then setup the distribution
  if (!soln.built())
   {
-   LinearAlgebraDistribution* dist_pt = 
-    new LinearAlgebraDistribution(x.distribution_pt()->communicator_pt(),
+    LinearAlgebraDistribution dist(x.distribution_pt()->communicator_pt(),
                                   this->nrow(),false);
-   soln.build(dist_pt,0.0);
-   delete dist_pt;
+    soln.build(&dist,0.0);
   }
  soln.initialise(0.0);
 
@@ -500,6 +498,9 @@
      soln_pt[i] += Matrixdata[M*i+j]*x_pt[j];
     }
   }
+
+ //??ds Do I need to replace this with a call to the BLAS routine for dense multiplication
+
 }
 
 
@@ -1469,6 +1470,50 @@
  Built = true;
 }
 
+
+//======================================================================
+/// A constructor to easily create CRMatrices from arrays of values, and rows +
+/// column indices. Must be alread sorted by row.
+// Not efficient, not distributable. Don't use this for anything real!
+//======================================================================
+CRDoubleMatrix::CRDoubleMatrix(const Vector<double>& values,
+			       const Vector<int>& row_indices,
+			       const Vector<int>& col_indices,
+			       const unsigned& nrow, const unsigned& ncol)
+{
+#ifdef PARANOID
+  if(( *(max_element(row_indices.begin(),row_indices.end())) > int(nrow))
+     || ( *(max_element(col_indices.begin(),col_indices.end())) > int(ncol)))
+    {
+      throw OomphLibError("Row or column index out of range.",
+			  "CRDoubleMatrix::CRDoubleMatrix",
+			  OOMPH_EXCEPTION_LOCATION);
+    }
+#endif
+
+  // Count the number of entries for each row (assuming everything is sorted)
+  Vector<int> row_start;
+  row_start.push_back(0); // First entry is always zero
+  for(unsigned j=0; j<nrow; j++)
+    {
+      unsigned entries_this_row = 0;
+      for(unsigned i=0; i<row_indices.size(); i++)
+	if(unsigned(row_indices[i]) == j)
+	  entries_this_row++;
+      row_start.push_back(row_start.back() + entries_this_row);
+    }
+
+  // Store a dummy Distribution
+  LinearAlgebraDistribution dist(0,nrow);
+
+  // Construct the matrix
+  this->build(&dist, ncol, values, col_indices, row_start);
+
+  // Set the linear solver
+  Linear_solver_pt = Default_linear_solver_pt = new SuperLUSolver;
+}
+
+
 //=============================================================================
 /// Destructor
 //=============================================================================
@@ -1496,6 +1541,8 @@
  this->clear_distribution();
  CR_matrix.clean_up_memory();
  Built = false;
+
+  if(Linear_solver_pt != 0) // Only clean up if it exists
  Linear_solver_pt->clean_up_memory();
 }
 
@@ -3101,4 +3148,49 @@
    // and return
    return n;
   }
+
+void SumOfMatrices::multiply(const DoubleVector &x, DoubleVector &soln) const
+{
+  // We assume that appropriate checks and initialisation on x and soln are
+  // carried out within the individual matrix multiplys.
+
+  // Multiply for the first matrix
+  Main_matrix_pt->multiply(x,soln);
+
+  // Now add contribution for other matrices
+  for(unsigned i_matrix=0; i_matrix< Added_matrix_pt.size(); i_matrix++)
+    {
+      // Create temporary output DoubleVector with no proper distribution
+      //??ds parallelising this might be hard - not sure where to get hte
+      //distribution from
+      LinearAlgebraDistribution dist(0,Main_to_individual_rows_pt[i_matrix]->size());
+      DoubleVector temp_soln(dist);
+
+	  // Create a const iterator for the map (faster than .find() or []
+	  // access, const means can't change the map via the iterator)
+	  index_map::const_iterator it;
+
+	  // Pull out the appropriate values into a temp vector
+	  DoubleVector temp_x(dist);
+	  for(it = Main_to_individual_rows_pt[i_matrix]->begin();
+	      it != Main_to_individual_rows_pt[i_matrix]->end();
+	      it++)
+	    {
+	      temp_x[it->second] = x[it->first];
 }
+
+	  // Perform the multiplication
+	  Added_matrix_pt[i_matrix]->multiply(temp_x,temp_soln);
+
+	  // Add result to solution vector
+	  for(it = Main_to_individual_rows_pt[i_matrix]->begin();
+	      it != Main_to_individual_rows_pt[i_matrix]->end();
+	      it++)
+	    {
+	      soln[it->first] += temp_soln[it->second];
+	    }
+	}
+
+}
+
+}
Index: src/generic/lapack_qz.h
===================================================================
--- src/generic/lapack_qz.h	(revision 274)
+++ src/generic/lapack_qz.h	(working copy)
@@ -31,8 +31,8 @@
 //PROTOCCALLSFFUN5( DOUBLE, DDOT, ddot, INT, DOUBLEV, INT, DOUBLEV, INT ) 
 //#define BLAS_DDOT(N,X,INCX,Y,INCY) CCALLSFFUN5(DDOT,ddot,INT,DOUBLEV,INT,DOUBLEV,INT,N,X,INCX,Y,INCY) 
 
-/// The BLAS DOUBLE matrix multiplier 
-/// Fortran interface : SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) 
+// /// The BLAS DOUBLE matrix multiplier
+// /// Fortran interface : SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)
 //PROTOCCALLSFSUB13( DGEMM, dgemm, STRING, STRING, INT, INT, INT, DOUBLE, DOUBLEV, INT, DOUBLEV, INT, DOUBLE, DOUBLEV, INT ) 
 //#define BLAS_DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) CCALLSFSUB13(DGEMM,dgemm,STRING,STRING,INT,INT,INT,DOUBLE,DOUBLEV,INT,DOUBLEV,INT,DOUBLE,DOUBLEV,INT,TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC) 
 
@@ -56,4 +56,3 @@
 PROTOCCALLSFSUB17( ZGGEV, zggev, STRING, STRING, INT, DOUBLEV, INT, DOUBLEV, INT, DOUBLEV, DOUBLEV, DOUBLEV, INT, DOUBLEV, INT, DOUBLEV, INT, DOUBLEV, PINT ) 
 /// jobvl jobvr n a lda b ldb alpha beta vl ldvl vr ldvr work lwork rwork info 
 #define LAPACK_ZGGEV(JOBVL,JOBVR,N,A,LDA,B,LDB,ALPHA,BETA,VL,LDVL,VR,LDVR,WORK,LWORK,RWORK,INFO) CCALLSFSUB17(ZGGEV,zggev,STRING,STRING,INT,DOUBLEV,INT,DOUBLEV,INT,DOUBLEV,DOUBLEV,DOUBLEV,INT,DOUBLEV,INT,DOUBLEV,INT,DOUBLEV,PINT,JOBVL,JOBVR,N,A,LDA,B,LDB,ALPHA,BETA,VL,LDVL,VR,LDVR,WORK,LWORK,RWORK,INFO) 
-
Index: src/generic/problem.h
===================================================================
--- src/generic/problem.h	(revision 274)
+++ src/generic/problem.h	(working copy)
@@ -1457,6 +1457,19 @@
  virtual void get_jacobian(DoubleVector &residuals, 
                            CCDoubleMatrix &jacobian);
 
+  /// \short Dummy virtual function that must be overloaded by the problem to
+  /// specify which matrices should be summed to give the final Jacobian.
+  virtual void get_jacobian(DoubleVector &residuals,
+			    SumOfMatrices &jacobian)
+  {
+    std::ostringstream error_stream;
+    error_stream
+      << "You must overload this function in your problem class to specify\n"
+      << "which matrices should be summed to give the final Jacobian.";
+    throw OomphLibError(error_stream.str(),
+			"Problem::get_jacobian", OOMPH_EXCEPTION_LOCATION);
+  }
+
  /// \short Return the fully-assembled Jacobian and residuals, generated by
  /// finite differences
  void get_fd_jacobian(DoubleVector &residuals, 
Index: src/generic/elements.h
===================================================================
--- src/generic/elements.h	(revision 274)
+++ src/generic/elements.h	(working copy)
@@ -1221,7 +1221,7 @@
 
  /// \short Return the local equation number corresponding to the i-th
  /// value at the n-th local node.
- inline int nodal_local_eqn(const unsigned &n, const unsigned &i)
+ inline int nodal_local_eqn(const unsigned &n, const unsigned &i) const
   {
 #ifdef RANGE_CHECKING
    if(n >= Nnode)
Index: src/generic/frontal_solver.cc
===================================================================
--- src/generic/frontal_solver.cc	(revision 274)
+++ src/generic/frontal_solver.cc	(working copy)
@@ -642,7 +642,7 @@
        //could get too large
        double **avar = new double*[nvar];
        double *tmp = new double[nvar*nmaxe];
-       for(unsigned i=0;i<nvar;i++) {avar[i] = &tmp[i*nmaxe];}
+       for(unsigned i=0;i<unsigned(nvar);i++) {avar[i] = &tmp[i*nmaxe];}
        double **rhs = new double*[1];
        rhs[0] = new double[nmaxe];
 
Index: src/generic/elements.cc
===================================================================
--- src/generic/elements.cc	(revision 274)
+++ src/generic/elements.cc	(working copy)
@@ -3606,13 +3606,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -3681,13 +3679,11 @@
   assemble_eulerian_base_vectors(dpsids,interpolated_G);
  
   //Calculate the metric tensor of the element
-  DenseMatrix<double> G(n_dim_element);
+  DenseMatrix<double> G(n_dim_element,n_dim_element,0.0);
   for(unsigned i=0;i<n_dim_element;i++)
    {
     for(unsigned j=0;j<n_dim_element;j++)
      {
-      //Initialise to zero
-      G(i,j) = 0.0;
       for(unsigned k=0;k<n_dim_node;k++) 
        {
         G(i,j) += interpolated_G(i,k)*interpolated_G(j,k);
@@ -4578,13 +4574,11 @@
      }
    }
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4666,13 +4660,11 @@
    }
 
   //Now find the local deformed metric tensor from the tangent Vectors
-  DenseMatrix<double> A(n_dim_el);
+  DenseMatrix<double> A(n_dim_el,n_dim_el,0.0);
   for(unsigned i=0;i<n_dim_el;i++)
    {
     for(unsigned j=0;j<n_dim_el;j++)
      {
-      //Initialise surface metric tensor to zero
-      A(i,j) = 0.0;
       //Take the dot product
       for(unsigned k=0;k<n_dim;k++)
        { 
@@ -4829,9 +4821,7 @@
  
     //Calculate all derivatives of the spatial coordinates wrt 
     //local coordinates
-    DenseMatrix<double> interpolated_dxds(1,spatial_dim);
-    //Initialise to zero
-    for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(0,i) = 0.0;}
+    DenseMatrix<double> interpolated_dxds(1,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4882,10 +4872,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,spatial_dim);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<spatial_dim;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,spatial_dim,0.0);
     
     //Loop over all parent nodes
     for(unsigned l=0;l<n_node_bulk;l++)
@@ -4989,10 +4976,7 @@
  
     //Calculate all derivatives of the spatial coordinates 
     //wrt local coordinates
-    DenseMatrix<double> interpolated_dxds(2,3);
-    //Initialise to zero
-    for(unsigned j=0;j<2;j++)
-     {for(unsigned i=0;i<3;i++) {interpolated_dxds(j,i) = 0.0;}}
+    DenseMatrix<double> interpolated_dxds(2,3,0.0);
     
     //Loop over all nodes
     for(unsigned l=0;l<n_node;l++)
@@ -6012,13 +5996,11 @@
    shape(s,psi);
 
    // Get Lagrangian coordinate
-   Vector<double> xi(n_lagrangian);
+   Vector<double> xi(n_lagrangian,0.0);
 
    //Loop over the number of lagrangian coordinates
    for(unsigned i=0;i<n_lagrangian;i++)
     {
-     //Initialise component to zero
-     xi[i] = 0.0;
      //Loop over the local nodes
      for(unsigned l=0;l<n_node;l++) 
       {
Index: src/generic/iterative_linear_solver.cc
===================================================================
--- src/generic/iterative_linear_solver.cc	(revision 274)
+++ src/generic/iterative_linear_solver.cc	(working copy)
@@ -1925,5 +1925,6 @@
 template class GMRES<CCDoubleMatrix>;
 template class GMRES<CRDoubleMatrix>;
 template class GMRES<DenseDoubleMatrix>;
+template class GMRES<SumOfMatrices>;
 
 }
Index: src/generic/trilinos_helpers.cc
===================================================================
--- src/generic/trilinos_helpers.cc	(revision 274)
+++ src/generic/trilinos_helpers.cc	(working copy)
@@ -731,7 +731,7 @@
  copy_to_oomphlib_vector(epetra_y_pt,oomph_y);
 
  // throw error if there is an epetra error
-#if PARANOID
+#ifdef PARANOID
  if (epetra_error_flag != 0)
   {
    std::ostringstream error_message;
Index: src/generic/preconditioner.h
===================================================================
--- src/generic/preconditioner.h	(revision 274)
+++ src/generic/preconditioner.h	(working copy)
@@ -148,7 +148,13 @@
       unsigned n_row=matrix_pt->nrow();
 
       // create the distribution
-      LinearAlgebraDistribution dist(problem_pt->communicator_pt(),n_row,false);
+      // LinearAlgebraDistribution dist(problem_pt->communicator_pt(),n_row,false);
+
+      //??ds this was stopping me using a linear solve without a problem so I
+      // made a dummy communicator - might be ok because this is only for the
+      // non-distributed case anyway...
+      OomphCommunicator* communicator_pt = new OomphCommunicator();
+      LinearAlgebraDistribution dist(communicator_pt,n_row,false);
       this->build_distribution(dist);
      }
    }
