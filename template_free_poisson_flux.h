//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented,
//LIC// multi-physics finite-element library, available
//LIC// at http://www.oomph-lib.org.
//LIC//
//LIC//           Version 0.90. August 3, 2009.
//LIC//
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC//
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC//
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC//
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC//
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC//
//LIC//====================================================================
// Header file for elements that are used to apply prescribed flux
// boundary conditions to the Poisson equations
#ifndef OOMPH_TF_POISSON_FLUX_ELEMENTS_HEADER
#define OOMPH_TF_POISSON_FLUX_ELEMENTS_HEADER

#include "./template_free_poisson.h"
#include "../../src/generic/elements.h"
#include "../../src/generic/refineable_elements.h"



// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
  #include <oomph-lib-config.h>
#endif

namespace oomph
{

//======================================================================
/// \short A class for elements that allow the imposition of an
/// applied flux on the boundaries of Poisson elements.
/// The element geometry is obtained from the  FaceGeometry<ELEMENT>
/// policy class.
//======================================================================
class TFPoissonFluxEquations : public FaceElement
{

public:

 /// \short Function pointer to the prescribed-flux function fct(x,f(x)) --
 /// x is a Vector!
 typedef void (*PoissonPrescribedFluxFctPt)
  (const Vector<double>& x, double& flux);

 /// \short Constructor, takes the pointer to the "bulk" element and the
 /// index of the face to which the element is attached.
 TFPoissonFluxEquations(FiniteElement* const &bulk_el_pt,
                        const int& face_index);

 ///\short  Broken empty constructor
 TFPoissonFluxEquations()
  {
   throw OomphLibError(
    "Don't call empty constructor for TFPoissonFluxEquations",
    OOMPH_CURRENT_FUNCTION,
    OOMPH_EXCEPTION_LOCATION);
  }

 /// Broken copy constructor
 TFPoissonFluxEquations(const TFPoissonFluxEquations& dummy)
  {
   BrokenCopy::broken_copy("TFPoissonFluxEquations");
  }

 /// Broken assignment operator
 void operator=(const TFPoissonFluxEquations&)
  {
   BrokenCopy::broken_assign("TFPoissonFluxEquations");
  }

 /// \short Specify the value of nodal zeta from the face geometry
 /// The "global" intrinsic coordinate of the element when
 /// viewed as part of a geometric object should be given by
 /// the FaceElement representation, by default (needed to break
 /// indeterminacy if bulk element is SolidElement)
 double zeta_nodal(const unsigned &n, const unsigned &k,
                          const unsigned &i) const
  {return FaceElement::zeta_nodal(n,k,i);}


  /// Doesn't need to store any values: This element just modifies the
  /// residuals at the surface.
  unsigned required_nvalue(const unsigned &n) const {return 0;}

 /// Access function for the prescribed-flux function pointer
 PoissonPrescribedFluxFctPt& flux_fct_pt() {return Flux_fct_pt;}


 /// Add the element's contribution to its residual vector
 inline void fill_in_contribution_to_residuals(Vector<double> &residuals)
  {
   //Call the generic residuals function with flag set to 0
   //using a dummy matrix argument
   fill_in_generic_residual_contribution_poisson_flux(
    residuals,GeneralisedElement::Dummy_matrix,0);
  }


 /// \short Add the element's contribution to its residual vector and its
 /// Jacobian matrix
 inline void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                          DenseMatrix<double> &jacobian)
  {
   //Call the generic routine with the flag set to 1
   fill_in_generic_residual_contribution_poisson_flux(residuals,jacobian,1);
  }

protected:

 /// \short Function to compute the shape and test functions and to return
 /// the Jacobian of mapping between local and global (Eulerian)
 /// coordinates
 inline double shape_and_test(const Vector<double> &s, Shape &psi, Shape &test)
  const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape(s,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian(s);
  }


 /// \short Function to compute the shape and test functions and to return
 /// the Jacobian of mapping between local and global (Eulerian)
 /// coordinates
 inline double shape_and_test_at_knot(const unsigned &ipt,
                                      Shape &psi, Shape &test)
  const
  {
   //Find number of nodes
   unsigned n_node = nnode();

   //Get the shape functions
   shape_at_knot(ipt,psi);

   //Set the test functions to be the same as the shape functions
   for(unsigned i=0;i<n_node;i++) {test[i] = psi[i];}

   //Return the value of the jacobian
   return J_eulerian_at_knot(ipt);
  }


 /// Function to calculate the prescribed flux at a given spatial
 /// position
 void get_flux(const Vector<double>& x, double& flux)
  {
   //If the function pointer is zero return zero
   if(Flux_fct_pt == 0)
    {
     flux=0.0;
    }
   //Otherwise call the function
   else
    {
     (*Flux_fct_pt)(x,flux);
    }
  }

  //??Ds stupid function but I seem to need it...
  virtual void get_elemental_flux(const Vector<double> &s,
                                  double& flux) const {}

private:


 /// \short Add the element's contribution to its residual vector.
 /// flag=1(or 0): do (or don't) compute the contribution to the
 /// Jacobian as well.
 void fill_in_generic_residual_contribution_poisson_flux(
  Vector<double> &residuals, DenseMatrix<double> &jacobian,
  const unsigned& flag);


 /// Function pointer to the (global) prescribed-flux function
 PoissonPrescribedFluxFctPt Flux_fct_pt;

 ///The spatial dimension of the problem
 unsigned Dim;

 ///The index at which the unknown is stored at the nodes
 unsigned U_index_poisson;


};

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


template<unsigned DIM, unsigned NNODE_1D>
class QTFPoissonFluxElement : public virtual FaceGeometry<QElement<DIM, NNODE_1D> >,
                              public virtual TFPoissonFluxEquations
{

public:
 QTFPoissonFluxElement(FiniteElement* const &bulk_el_pt,
                       const int& face_index)
  : FaceGeometry<QElement<DIM, NNODE_1D> >(),
    TFPoissonFluxEquations(bulk_el_pt, face_index)
 {}

};


template<unsigned DIM, unsigned NNODE_1D>
class TTFPoissonFluxElement : public virtual FaceGeometry<TElement<DIM, NNODE_1D> >,
                              public virtual TFPoissonFluxEquations
{

public:
 TTFPoissonFluxElement(FiniteElement* const &bulk_el_pt,
                       const int& face_index)
  : FaceGeometry<TElement<DIM, NNODE_1D> >(),
    TFPoissonFluxEquations(bulk_el_pt, face_index)
 {}

};




}

#endif
