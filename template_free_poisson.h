//LIC// ====================================================================
//LIC// This file forms part of oomph-lib, the object-oriented,
//LIC// multi-physics finite-element library, available
//LIC// at http://www.oomph-lib.org.
//LIC//
//LIC//           Version 0.90. August 3, 2009.
//LIC//
//LIC// Copyright (C) 2006-2009 Matthias Heil and Andrew Hazel
//LIC//
//LIC// This library is free software; you can redistribute it and/or
//LIC// modify it under the terms of the GNU Lesser General Public
//LIC// License as published by the Free Software Foundation; either
//LIC// version 2.1 of the License, or (at your option) any later version.
//LIC//
//LIC// This library is distributed in the hope that it will be useful,
//LIC// but WITHOUT ANY WARRANTY; without even the implied warranty of
//LIC// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//LIC// Lesser General Public License for more details.
//LIC//
//LIC// You should have received a copy of the GNU Lesser General Public
//LIC// License along with this library; if not, write to the Free Software
//LIC// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
//LIC// 02110-1301  USA.
//LIC//
//LIC// The authors may be contacted at oomph-lib@maths.man.ac.uk.
//LIC//
//LIC//====================================================================
//Header file for Poisson elements
#ifndef OOMPH_TF_POISSON_ELEMENTS_HEADER
#define OOMPH_TF_POISSON_ELEMENTS_HEADER


// Config header generated by autoconfig
#ifdef HAVE_CONFIG_H
#include <oomph-lib-config.h>
#endif

#include<sstream>

// //OOMPH-LIB headers
// #include "../../../generic/projection.h"
// #include "../../../generic/nodes.h"
// #include "../../../generic/Qelements.h"
// #include "../../../generic/oomph_utilities.h"

#include "generic.h"


namespace oomph
{

  //=============================================================
  /// A class for all isoparametric elements that solve the
  /// Poisson equations.
  /// \f[
  /// \frac{\partial^2 u}{\partial x_i^2} = f(x_j)
  /// \f]
  /// This contains the generic maths. Shape functions, geometric
  /// mapping etc. must get implemented in derived class.
  //=============================================================
  class TFPoissonEquations : public virtual FiniteElement
  {

  public:

    /// \short Function pointer to source function fct(x,f(x)) --
    /// x is a Vector!
    typedef void (*PoissonSourceFctPt)(const Vector<double>& x, double& f);


    /// \short Function pointer to gradient of source function  fct(x,g(x)) --
    /// x is a Vector!
    typedef void (*PoissonSourceFctGradientPt)(const Vector<double>& x,
                                               Vector<double>& gradient);


    /// Constructor (must initialise the Source_fct_pt to null)
    TFPoissonEquations() : Source_fct_pt(0), Source_fct_gradient_pt(0)
    {}

    /// Broken copy constructor
    TFPoissonEquations(const TFPoissonEquations& dummy)
    {
      BrokenCopy::broken_copy("TFPoissonEquations");
    }

    /// Broken assignment operator
    void operator=(const TFPoissonEquations&)
    {
      BrokenCopy::broken_assign("TFPoissonEquations");
    }

    /// \short Return the index at which the unknown value
    /// is stored. The default value, 0, is appropriate for single-physics
    /// problems, when there is only one variable, the value that satisfies
    /// the poisson equation.
    /// In derived multi-physics elements, this function should be overloaded
    /// to reflect the chosen storage scheme. Note that these equations require
    /// that the unknown is always stored at the same index at each node.
    virtual inline unsigned u_index_poisson() const {return 0;}

    /// Output with default number of plot points
    void output(std::ostream &outfile)
    {
      const unsigned n_plot=5;
      output(outfile,n_plot);
    }

    /// \short Output FE representation of soln: x,y,u or x,y,z,u at
    /// n_plot^DIM plot points
    void output(std::ostream &outfile, const unsigned &n_plot);

    /// C_style output with default number of plot points
    void output(FILE* file_pt)
    {
      const unsigned n_plot=5;
      output(file_pt,n_plot);
    }

    /// \short C-style output FE representation of soln: x,y,u or x,y,z,u at
    /// n_plot^DIM plot points
    void output(FILE* file_pt, const unsigned &n_plot);

    /// Output exact soln: x,y,u_exact or x,y,z,u_exact at n_plot^DIM plot points
    void output_fct(std::ostream &outfile, const unsigned &n_plot,
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt);

    /// \short Output exact soln: x,y,u_exact or x,y,z,u_exact at
    /// n_plot^DIM plot points (dummy time-dependent version to
    /// keep intel compiler happy)
    virtual void output_fct(std::ostream &outfile, const unsigned &n_plot,
                            const double& time,
                            FiniteElement::UnsteadyExactSolutionFctPt
                            exact_soln_pt)
    {
      throw OomphLibError(
                          "There is no time-dependent output_fct() for Poisson elements ",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }


    /// Get error against and norm of exact solution
    void compute_error(std::ostream &outfile,
                       FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                       double& error, double& norm);


    /// Dummy, time dependent error checker
    void compute_error(std::ostream &outfile,
                       FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt,
                       const double& time, double& error, double& norm)
    {
      throw OomphLibError(
                          "There is no time-dependent compute_error() for Poisson elements",
                          OOMPH_CURRENT_FUNCTION,
                          OOMPH_EXCEPTION_LOCATION);
    }

    /// Access function: Pointer to source function
    PoissonSourceFctPt& source_fct_pt() {return Source_fct_pt;}

    /// Access function: Pointer to source function. Const version
    PoissonSourceFctPt source_fct_pt() const {return Source_fct_pt;}

    /// Access function: Pointer to gradient of source function
    PoissonSourceFctGradientPt& source_fct_gradient_pt()
    {return Source_fct_gradient_pt;}

    /// Access function: Pointer to gradient source function. Const version
    PoissonSourceFctGradientPt source_fct_gradient_pt() const
    {return Source_fct_gradient_pt;}


    /// Get source term at (Eulerian) position x. This function is
    /// virtual to allow overloading in multi-physics problems where
    /// the strength of the source function might be determined by
    /// another system of equations.
    inline virtual void get_source_poisson(const unsigned& ipt,
                                           const Vector<double>& x,
                                           double& source) const
    {
      //If no source function has been set, return zero
      if(Source_fct_pt==0) {source = 0.0;}
      else
        {
          // Get source strength
          (*Source_fct_pt)(x,source);
        }
    }


    /// Get gradient of source term at (Eulerian) position x. This function is
    /// virtual to allow overloading in multi-physics problems where
    /// the strength of the source function might be determined by
    /// another system of equations. Computed via function pointer
    /// (if set) or by finite differencing (default)
    inline virtual void get_source_gradient_poisson(
                                                    const unsigned& ipt,
                                                    const Vector<double>& x,
                                                    Vector<double>& gradient) const
    {
      //If no gradient function has been set, FD it
      if(Source_fct_gradient_pt==0)
        {
          // Reference value
          double source=0.0;
          get_source_poisson(ipt,x,source);

          // FD it
          double eps_fd=GeneralisedElement::Default_fd_jacobian_step;
          double source_pls=0.0;
          Vector<double> x_pls(x);
          for (unsigned i=0;i<nodal_dimension();i++)
            {
              x_pls[i]+=eps_fd;
              get_source_poisson(ipt,x_pls,source_pls);
              gradient[i]=(source_pls-source)/eps_fd;
              x_pls[i]=x[i];
            }
        }
      else
        {
          // Get gradient
          (*Source_fct_gradient_pt)(x,gradient);
        }
    }




    /// Get flux: flux[i] = du/dx_i
    void get_flux(const Vector<double>& s, Vector<double>& flux) const
    {
      //Find out how many nodes there are in the element
      const unsigned n_node = nnode();

      //Get the index at which the unknown is stored
      const unsigned u_nodal_index = u_index_poisson();

      //Set up memory for the shape and test functions
      Shape psi(n_node);
      DShape dpsidx(n_node,nodal_dimension());

      //Call the derivatives of the shape and test functions
      dshape_eulerian(s,psi,dpsidx);

      //Initialise to zero
      for(unsigned j=0;j<nodal_dimension();j++)
        {
          flux[j] = 0.0;
        }

      // Loop over nodes
      for(unsigned l=0;l<n_node;l++)
        {
          //Loop over derivative directions
          for(unsigned j=0;j<nodal_dimension();j++)
            {
              flux[j] += this->nodal_value(l,u_nodal_index)*dpsidx(l,j);
            }
        }
    }


    /// Add the element's contribution to its residual vector (wrapper)
    void fill_in_contribution_to_residuals(Vector<double> &residuals)
    {
      //Call the generic residuals function with flag set to 0
      //using a dummy matrix argument
      fill_in_generic_residual_contribution_poisson(
                                                    residuals,GeneralisedElement::Dummy_matrix,0);
    }


    /// Add the element's contribution to its residual vector and
    /// element Jacobian matrix (wrapper)
    void fill_in_contribution_to_jacobian(Vector<double> &residuals,
                                          DenseMatrix<double> &jacobian)
    {
      //Call the generic routine with the flag set to 1
      fill_in_generic_residual_contribution_poisson(residuals,jacobian,1);
    }



    /// \short Return FE representation of function value u_poisson(s)
    /// at local coordinate s
    inline double interpolated_u_poisson(const Vector<double> &s) const
    {
      //Find number of nodes
      const unsigned n_node = nnode();

      //Get the index at which the poisson unknown is stored
      const unsigned u_nodal_index = u_index_poisson();

      //Local shape function
      Shape psi(n_node);

      //Find values of shape function
      shape(s,psi);

      //Initialise value of u
      double interpolated_u = 0.0;

      //Loop over the local nodes and sum
      for(unsigned l=0;l<n_node;l++)
        {
          interpolated_u += this->nodal_value(l,u_nodal_index)*psi[l];
        }

      return(interpolated_u);
    }


    /// \short Compute derivatives of elemental residual vector with respect
    /// to nodal coordinates. Overwrites default implementation in
    /// FiniteElement base class.
    /// dresidual_dnodal_coordinates(l,i,j) = d res(l) / dX_{ij}
    virtual void get_dresidual_dnodal_coordinates(RankThreeTensor<double>&
                                                  dresidual_dnodal_coordinates);

    /// \short Self-test: Return 0 for OK
    unsigned self_test();


  protected:

    /// \short Shape/test functions and derivs w.r.t. to global coords at
    /// local coord. s; return  Jacobian of mapping
    virtual double dshape_and_dtest_eulerian_poisson(const Vector<double> &s,
                                                     Shape &psi,
                                                     DShape &dpsidx, Shape &test,
                                                     DShape &dtestdx) const=0;


    /// \short Shape/test functions and derivs w.r.t. to global coords at
    /// integration point ipt; return  Jacobian of mapping
    virtual double dshape_and_dtest_eulerian_at_knot_poisson(const unsigned &ipt,
                                                             Shape &psi,
                                                             DShape &dpsidx,
                                                             Shape &test,
                                                             DShape &dtestdx)
      const=0;

    /// \short Shape/test functions and derivs w.r.t. to global coords at
    /// integration point ipt; return Jacobian of mapping (J). Also compute
    /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
    virtual double dshape_and_dtest_eulerian_at_knot_poisson(
                                                             const unsigned &ipt,
                                                             Shape &psi,
                                                             DShape &dpsidx,
                                                             RankFourTensor<double> &d_dpsidx_dX,
                                                             Shape &test,
                                                             DShape &dtestdx,
                                                             RankFourTensor<double> &d_dtestdx_dX,
                                                             DenseMatrix<double> &djacobian_dX) const=0;

    /// \short Compute element residual Vector only (if flag=and/or element
    /// Jacobian matrix
    virtual void fill_in_generic_residual_contribution_poisson(
                                                               Vector<double> &residuals, DenseMatrix<double> &jacobian,
                                                               const unsigned& flag);

    /// Pointer to source function:
    PoissonSourceFctPt Source_fct_pt;

    /// Pointer to gradient of source function
    PoissonSourceFctGradientPt Source_fct_gradient_pt;

  };






  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////////////////////////////////////////



  //======================================================================
  /// QTFPoissonElement elements are linear/quadrilateral/brick-shaped
  /// Poisson elements with isoparametric interpolation for the function.
  //======================================================================
  template <unsigned DIM, unsigned NNODE_1D>
  class QTFPoissonElement : public virtual QElement<DIM,NNODE_1D>,
                          public virtual TFPoissonEquations
  {

  private:

    /// \short Static int that holds the number of variables at
    /// nodes: always the same
    static const unsigned Initial_Nvalue;

  public:


    ///\short  Constructor: Call constructors for QElement and
    /// Poisson equations
    QTFPoissonElement() : QElement<DIM,NNODE_1D>(), TFPoissonEquations()
    {}

    /// Broken copy constructor
    QTFPoissonElement(const QTFPoissonElement<DIM,NNODE_1D>& dummy)
    {
      BrokenCopy::broken_copy("QTFPoissonElement");
    }

    /// Broken assignment operator
    void operator=(const QTFPoissonElement<DIM,NNODE_1D>&)
    {
      BrokenCopy::broken_assign("QTFPoissonElement");
    }


    /// \short  Required  # of `values' (pinned or dofs)
    /// at node n
    inline unsigned required_nvalue(const unsigned &n) const
    {return Initial_Nvalue;}

    /// \short Output function:
    ///  x,y,u   or    x,y,z,u
    void output(std::ostream &outfile)
    {TFPoissonEquations::output(outfile);}


    ///  \short Output function:
    ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
    void output(std::ostream &outfile, const unsigned &n_plot)
    {TFPoissonEquations::output(outfile,n_plot);}


    /// \short C-style output function:
    ///  x,y,u   or    x,y,z,u
    void output(FILE* file_pt)
    {TFPoissonEquations::output(file_pt);}


    ///  \short C-style output function:
    ///   x,y,u   or    x,y,z,u at n_plot^DIM plot points
    void output(FILE* file_pt, const unsigned &n_plot)
    {TFPoissonEquations::output(file_pt,n_plot);}


    /// \short Output function for an exact solution:
    ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
    void output_fct(std::ostream &outfile, const unsigned &n_plot,
                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt)
    {TFPoissonEquations::output_fct(outfile,n_plot,exact_soln_pt);}



    /// \short Output function for a time-dependent exact solution.
    ///  x,y,u_exact   or    x,y,z,u_exact at n_plot^DIM plot points
    /// (Calls the steady version)
    void output_fct(std::ostream &outfile, const unsigned &n_plot,
                    const double& time,
                    FiniteElement::UnsteadyExactSolutionFctPt exact_soln_pt)
    {TFPoissonEquations::output_fct(outfile,n_plot,time,exact_soln_pt);}


  protected:

    /// Shape, test functions & derivs. w.r.t. to global coords. Return Jacobian.
    inline double dshape_and_dtest_eulerian_poisson(
                                                    const Vector<double> &s, Shape &psi, DShape &dpsidx,
                                                    Shape &test, DShape &dtestdx) const;


    /// \short Shape, test functions & derivs. w.r.t. to global coords. at
    /// integration point ipt. Return Jacobian.
    inline double dshape_and_dtest_eulerian_at_knot_poisson(const unsigned& ipt,
                                                            Shape &psi,
                                                            DShape &dpsidx,
                                                            Shape &test,
                                                            DShape &dtestdx)
      const;

    /// \short Shape/test functions and derivs w.r.t. to global coords at
    /// integration point ipt; return Jacobian of mapping (J). Also compute
    /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
    inline double dshape_and_dtest_eulerian_at_knot_poisson(
                                                            const unsigned &ipt,
                                                            Shape &psi,
                                                            DShape &dpsidx,
                                                            RankFourTensor<double> &d_dpsidx_dX,
                                                            Shape &test,
                                                            DShape &dtestdx,
                                                            RankFourTensor<double> &d_dtestdx_dX,
                                                            DenseMatrix<double> &djacobian_dX) const;

  };




  //Inline functions:


  //======================================================================
  /// Define the shape functions and test functions and derivatives
  /// w.r.t. global coordinates and return Jacobian of mapping.
  ///
  /// Galerkin: Test functions = shape functions
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  double QTFPoissonElement<DIM,NNODE_1D>::dshape_and_dtest_eulerian_poisson(
                                                                          const Vector<double> &s,
                                                                          Shape &psi,
                                                                          DShape &dpsidx,
                                                                          Shape &test,
                                                                          DShape &dtestdx) const
  {
    //Call the geometrical shape functions and derivatives
    const double J = this->dshape_eulerian(s,psi,dpsidx);

    //Set the test functions equal to the shape functions
    test = psi;
    dtestdx= dpsidx;

    //Return the jacobian
    return J;
  }




  //======================================================================
  /// Define the shape functions and test functions and derivatives
  /// w.r.t. global coordinates and return Jacobian of mapping.
  ///
  /// Galerkin: Test functions = shape functions
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  double QTFPoissonElement<DIM,NNODE_1D>::
  dshape_and_dtest_eulerian_at_knot_poisson(
                                            const unsigned &ipt,
                                            Shape &psi,
                                            DShape &dpsidx,
                                            Shape &test,
                                            DShape &dtestdx) const
  {
    //Call the geometrical shape functions and derivatives
    const double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx);

    //Set the pointers of the test functions
    test = psi;
    dtestdx = dpsidx;

    //Return the jacobian
    return J;
  }



  //======================================================================
  /// Define the shape functions (psi) and test functions (test) and
  /// their derivatives w.r.t. global coordinates (dpsidx and dtestdx)
  /// and return Jacobian of mapping (J). Additionally compute the
  /// derivatives of dpsidx, dtestdx and J w.r.t. nodal coordinates.
  ///
  /// Galerkin: Test functions = shape functions
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  double QTFPoissonElement<DIM,NNODE_1D>::
  dshape_and_dtest_eulerian_at_knot_poisson(
                                            const unsigned &ipt,
                                            Shape &psi,
                                            DShape &dpsidx,
                                            RankFourTensor<double> &d_dpsidx_dX,
                                            Shape &test,
                                            DShape &dtestdx,
                                            RankFourTensor<double> &d_dtestdx_dX,
                                            DenseMatrix<double> &djacobian_dX) const
  {
    // Call the geometrical shape functions and derivatives
    const double J = this->dshape_eulerian_at_knot(ipt,psi,dpsidx,
                                                   djacobian_dX,d_dpsidx_dX);

    // Set the pointers of the test functions
    test = psi;
    dtestdx = dpsidx;
    d_dtestdx_dX = d_dpsidx_dX;

    //Return the jacobian
    return J;
  }



  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////



  //=======================================================================
  /// Face geometry for the QElements: The spatial
  /// dimension of the face elements is one lower than that of the
  /// bulk element but they have the same number of points
  /// along their 1D edges.
  //=======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  class FaceGeometry<QElement<DIM,NNODE_1D> >:
    public virtual QElement<DIM-1,NNODE_1D>
  {

  public:

    /// \short Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : QElement<DIM-1,NNODE_1D>() {}

  };

  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////


  //=======================================================================
  /// Face geometry for the 1D QTFPoissonElement elements: Point elements
  //=======================================================================
  template<unsigned NNODE_1D>
  class FaceGeometry<QElement<1,NNODE_1D> >:
    public virtual PointElement
  {

  public:

    /// \short Constructor: Call the constructor for the
    /// appropriate lower-dimensional QElement
    FaceGeometry() : PointElement() {}

  };







  //??Ds this goes in the .cc file eventually



  //======================================================================
  /// Set the data for the number of Variables at each node, always one
  /// in every case
  //======================================================================
  template<unsigned DIM, unsigned NNODE_1D>
  const unsigned QTFPoissonElement<DIM,NNODE_1D>::Initial_Nvalue = 1;


  //======================================================================
  /// Compute element residual Vector and/or element Jacobian matrix
  ///
  /// flag=1: compute both
  /// flag=0: compute only residual Vector
  ///
  /// Pure version without hanging nodes
  //======================================================================
  void TFPoissonEquations::
  fill_in_generic_residual_contribution_poisson(Vector<double> &residuals,
                                                DenseMatrix<double> &jacobian,
                                                const unsigned& flag)
  {
    //Find out how many nodes there are
    const unsigned n_node = nnode();

    //Set up memory for the shape and test functions
    Shape psi(n_node), test(n_node);
    DShape dpsidx(n_node,nodal_dimension()), dtestdx(n_node,nodal_dimension());

    //Index at which the poisson unknown is stored
    const unsigned u_nodal_index = u_index_poisson();

    //Set the value of n_intpt
    const unsigned n_intpt = integral_pt()->nweight();

    //Integers to store the local equation and unknown numbers
    int local_eqn=0, local_unknown=0;

    //Loop over the integration points
    for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
        //Get the integral weight
        double w = integral_pt()->weight(ipt);

        //Call the derivatives of the shape and test functions
        double J = dshape_and_dtest_eulerian_at_knot_poisson(ipt,psi,dpsidx,
                                                             test,dtestdx);

        //Premultiply the weights and the Jacobian
        double W = w*J;

        //Calculate local values of unknown
        //Allocate and initialise to zero
        double interpolated_u=0.0;
        Vector<double> interpolated_x(nodal_dimension(),0.0);
        Vector<double> interpolated_dudx(nodal_dimension(),0.0);

        //Calculate function value and derivatives:
        //-----------------------------------------
        // Loop over nodes
        for(unsigned l=0;l<n_node;l++)
          {
            //Get the nodal value of the poisson unknown
            double u_value = raw_nodal_value(l,u_nodal_index);
            interpolated_u += u_value*psi(l);
            // Loop over directions
            for(unsigned j=0;j<nodal_dimension();j++)
              {
                interpolated_x[j] += raw_nodal_position(l,j)*psi(l);
                interpolated_dudx[j] += u_value*dpsidx(l,j);
              }
          }


        //Get source function
        //-------------------
        double source;
        get_source_poisson(ipt,interpolated_x,source);

        // Assemble residuals and Jacobian
        //--------------------------------

        // Loop over the test functions
        for(unsigned l=0;l<n_node;l++)
          {
            //Get the local equation
            local_eqn = nodal_local_eqn(l,u_nodal_index);
            // IF it's not a boundary condition
            if(local_eqn >= 0)
              {
                // Add body force/source term here
                residuals[local_eqn] += source*test(l)*W;

                // The Poisson bit itself
                for(unsigned k=0;k<nodal_dimension();k++)
                  {
                    residuals[local_eqn] += interpolated_dudx[k]*dtestdx(l,k)*W;
                  }

                // Calculate the jacobian
                //-----------------------
                if(flag)
                  {
                    //Loop over the velocity shape functions again
                    for(unsigned l2=0;l2<n_node;l2++)
                      {
                        local_unknown = nodal_local_eqn(l2,u_nodal_index);
                        //If at a non-zero degree of freedom add in the entry
                        if(local_unknown >= 0)
                          {
                            //Add contribution to Elemental Matrix
                            for(unsigned i=0;i<nodal_dimension();i++)
                              {
                                jacobian(local_eqn,local_unknown)
                                  += dpsidx(l2,i)*dtestdx(l,i)*W;
                              }
                          }
                      }
                  }
              }
          }

      } // End of loop over integration points
  }



  //======================================================================
  /// Compute derivatives of elemental residual vector with respect
  /// to nodal coordinates (fully analytical).
  /// dresidual_dnodal_coordinates(l,i,j) = d res(l) / dX_{ij}
  /// Overloads the FD-based version in the FE base class.
  //======================================================================
  void TFPoissonEquations::get_dresidual_dnodal_coordinates(
                                                          RankThreeTensor<double>&
                                                          dresidual_dnodal_coordinates)
  {
    // Determine number of nodes in element
    const unsigned n_node = nnode();

    // Set up memory for the shape and test functions
    Shape psi(n_node), test(n_node);
    DShape dpsidx(n_node,nodal_dimension()), dtestdx(n_node,nodal_dimension());

    // Deriatives of shape fct derivatives w.r.t. nodal coords
    RankFourTensor<double> d_dpsidx_dX(nodal_dimension(),n_node,n_node,nodal_dimension());
    RankFourTensor<double> d_dtestdx_dX(nodal_dimension(),n_node,n_node,nodal_dimension());

    // Derivative of Jacobian of mapping w.r.t. to nodal coords
    DenseMatrix<double> dJ_dX(nodal_dimension(),n_node);

    // Derivatives of derivative of u w.r.t. nodal coords
    RankThreeTensor<double> d_dudx_dX(nodal_dimension(),n_node,nodal_dimension());

    // Source function and its gradient
    double source;
    Vector<double> d_source_dx(nodal_dimension());

    // Index at which the poisson unknown is stored
    const unsigned u_nodal_index = u_index_poisson();

    // Determine the number of integration points
    const unsigned n_intpt = integral_pt()->nweight();

    // Integer to store the local equation number
    int local_eqn=0;

    // Loop over the integration points
    for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {
        // Get the integral weight
        double w = integral_pt()->weight(ipt);

        // Call the derivatives of the shape/test functions, as well as the
        // derivatives of these w.r.t. nodal coordinates and the derivative
        // of the jacobian of the mapping w.r.t. nodal coordinates
        const double J = dshape_and_dtest_eulerian_at_knot_poisson(
                                                                   ipt,psi,dpsidx,d_dpsidx_dX,test,dtestdx,d_dtestdx_dX,dJ_dX);

        // Calculate local values
        // Allocate and initialise to zero
        Vector<double> interpolated_x(nodal_dimension(),0.0);
        Vector<double> interpolated_dudx(nodal_dimension(),0.0);

        // Calculate function value and derivatives:
        // -----------------------------------------
        // Loop over nodes
        for(unsigned l=0;l<n_node;l++)
          {
            // Get the nodal value of the Poisson unknown
            double u_value = raw_nodal_value(l,u_nodal_index);

            // Loop over directions
            for(unsigned i=0;i<nodal_dimension();i++)
              {
                interpolated_x[i] += raw_nodal_position(l,i)*psi(l);
                interpolated_dudx[i] += u_value*dpsidx(l,i);
              }
          }

        // Calculate derivative of du/dx_i w.r.t. nodal positions X_{pq}
        for(unsigned q=0;q<n_node;q++)
          {
            // Loop over coordinate directions
            for(unsigned p=0;p<nodal_dimension();p++)
              {
                for(unsigned i=0;i<nodal_dimension();i++)
                  {
                    double aux=0.0;
                    for(unsigned j=0;j<n_node;j++)
                      {
                        aux += raw_nodal_value(j,u_nodal_index)*d_dpsidx_dX(p,q,j,i);
                      }
                    d_dudx_dX(p,q,i) = aux;
                  }
              }
          }

        // Get source function
        get_source_poisson(ipt,interpolated_x,source);

        // Get gradient of source function
        get_source_gradient_poisson(ipt,interpolated_x,d_source_dx);

        // Assemble d res_{local_eqn} / d X_{pq}
        // -------------------------------------

        // Loop over the test functions
        for(unsigned l=0;l<n_node;l++)
          {
            // Get the local equation
            local_eqn = nodal_local_eqn(l,u_nodal_index);

            // IF it's not a boundary condition
            if(local_eqn >= 0)
              {
                // Loop over coordinate directions
                for(unsigned p=0;p<nodal_dimension();p++)
                  {
                    // Loop over nodes
                    for(unsigned q=0;q<n_node;q++)
                      {
                        double sum = source*test(l)*dJ_dX(p,q)
                          + d_source_dx[p]*test(l)*psi(q)*J;

                        for(unsigned i=0;i<nodal_dimension();i++)
                          {
                            sum += interpolated_dudx[i]*(dtestdx(l,i)*dJ_dX(p,q) +
                                                         d_dtestdx_dX(p,q,l,i)*J)
                              + d_dudx_dX(p,q,i)*dtestdx(l,i)*J;
                          }

                        // Multiply through by integration weight
                        dresidual_dnodal_coordinates(local_eqn,p,q) += sum*w;
                      }
                  }
              }
          }
      } // End of loop over integration points
  }



  //======================================================================
  /// Self-test:  Return 0 for OK
  //======================================================================
  unsigned TFPoissonEquations::self_test()
  {

    bool passed=true;

    // Check lower-level stuff
    if (FiniteElement::self_test()!=0)
      {
        passed=false;
      }

    // Return verdict
    if (passed)
      {
        return 0;
      }
    else
      {
        return 1;
      }

  }



  //======================================================================
  /// Output function:
  ///
  ///   x,y,u   or    x,y,z,u
  ///
  /// nplot points in each coordinate direction
  //======================================================================
  void TFPoissonEquations::output(std::ostream &outfile,
                                const unsigned &nplot)
  {

    //Vector of local coordinates
    Vector<double> s(nodal_dimension());

    // Tecplot header info
    outfile << tecplot_zone_string(nplot);

    // Loop over plot points
    unsigned num_plot_points=nplot_points(nplot);
    for (unsigned iplot=0;iplot<num_plot_points;iplot++)
      {

        // Get local coordinates of plot point
        get_s_plot(iplot,nplot,s);

        for(unsigned i=0;i<nodal_dimension();i++)
          {
            outfile << interpolated_x(s,i) << " ";
          }
        outfile << interpolated_u_poisson(s) << std::endl;

      }

    // Write tecplot footer (e.g. FE connectivity lists)
    write_tecplot_zone_footer(outfile,nplot);

  }


  //======================================================================
  /// C-style output function:
  ///
  ///   x,y,u   or    x,y,z,u
  ///
  /// nplot points in each coordinate direction
  //======================================================================
  void TFPoissonEquations::output(FILE* file_pt,
                                const unsigned &nplot)
  {
    //Vector of local coordinates
    Vector<double> s(nodal_dimension());

    // Tecplot header info
    fprintf(file_pt,"%s",tecplot_zone_string(nplot).c_str());

    // Loop over plot points
    unsigned num_plot_points=nplot_points(nplot);
    for (unsigned iplot=0;iplot<num_plot_points;iplot++)
      {
        // Get local coordinates of plot point
        get_s_plot(iplot,nplot,s);

        for(unsigned i=0;i<nodal_dimension();i++)
          {
            fprintf(file_pt,"%g ",interpolated_x(s,i));
          }
        fprintf(file_pt,"%g \n",interpolated_u_poisson(s));
      }

    // Write tecplot footer (e.g. FE connectivity lists)
    write_tecplot_zone_footer(file_pt,nplot);
  }



  //======================================================================
  /// Output exact solution
  ///
  /// Solution is provided via function pointer.
  /// Plot at a given number of plot points.
  ///
  ///   x,y,u_exact    or    x,y,z,u_exact
  //======================================================================
  void TFPoissonEquations::output_fct(std::ostream &outfile,
                                    const unsigned &nplot,
                                    FiniteElement::SteadyExactSolutionFctPt exact_soln_pt)
  {
    //Vector of local coordinates
    Vector<double> s(nodal_dimension());

    // Vector for coordintes
    Vector<double> x(nodal_dimension());

    // Tecplot header info
    outfile << tecplot_zone_string(nplot);

    // Exact solution Vector (here a scalar)
    Vector<double> exact_soln(1);

    // Loop over plot points
    unsigned num_plot_points=nplot_points(nplot);
    for (unsigned iplot=0;iplot<num_plot_points;iplot++)
      {

        // Get local coordinates of plot point
        get_s_plot(iplot,nplot,s);

        // Get x position as Vector
        interpolated_x(s,x);

        // Get exact solution at this point
        (*exact_soln_pt)(x,exact_soln);

        //Output x,y,...,u_exact
        for(unsigned i=0;i<nodal_dimension();i++)
          {
            outfile << x[i] << " ";
          }
        outfile << exact_soln[0] << std::endl;
      }

    // Write tecplot footer (e.g. FE connectivity lists)
    write_tecplot_zone_footer(outfile,nplot);
  }




  //======================================================================
  /// Validate against exact solution
  ///
  /// Solution is provided via function pointer.
  /// Plot error at a given number of plot points.
  ///
  //======================================================================
  void TFPoissonEquations::compute_error(std::ostream &outfile,
                                         FiniteElement::SteadyExactSolutionFctPt exact_soln_pt,
                                         double& error, double& norm)
  {

    // Initialise
    error=0.0;
    norm=0.0;

    //Vector of local coordinates
    Vector<double> s(nodal_dimension());

    // Vector for coordintes
    Vector<double> x(nodal_dimension());

    //Find out how many nodes there are in the element
    unsigned n_node = nnode();

    Shape psi(n_node);

    //Set the value of n_intpt
    unsigned n_intpt = integral_pt()->nweight();

    // Tecplot
    outfile << "ZONE" << std::endl;

    // Exact solution Vector (here a scalar)
    Vector<double> exact_soln(1);

    //Loop over the integration points
    for(unsigned ipt=0;ipt<n_intpt;ipt++)
      {

        //Assign values of s
        for(unsigned i=0;i<nodal_dimension();i++)
          {
            s[i] = integral_pt()->knot(ipt,i);
          }

        //Get the integral weight
        double w = integral_pt()->weight(ipt);

        // Get jacobian of mapping
        double J=J_eulerian(s);

        //Premultiply the weights and the Jacobian
        double W = w*J;

        // Get x position as Vector
        interpolated_x(s,x);

        // Get FE function value
        double u_fe=interpolated_u_poisson(s);

        // Get exact solution at this point
        (*exact_soln_pt)(x,exact_soln);

        //Output x,y,...,error
        for(unsigned i=0;i<nodal_dimension();i++)
          {
            outfile << x[i] << " ";
          }
        outfile << exact_soln[0] << " " << exact_soln[0]-u_fe << std::endl;

        // Add to error and norm
        norm+=exact_soln[0]*exact_soln[0]*W;
        error+=(exact_soln[0]-u_fe)*(exact_soln[0]-u_fe)*W;

      }
  }




}

#endif
